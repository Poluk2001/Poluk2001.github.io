{"posts":[{"title":"一份简短的Git学习记录","text":"一：Git介绍 Git是免费的开源软件，用于分布式版本控制：跟踪任何一组文件的变化，通常用于协调软件开发过程中合作开发源代码的程序员之间的工作。它的目标包括速度、数据完整性和对分布式、非线性工作流程的支持（在不同系统上运行的数千个并行分支）。 版本控制 版本控制(Revision control)是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 团队协作 从单兵作战转换为团队作战 二：Git的安装Git官网：Git官网Git安装教程：安装教程 安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： 12$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com 三：初始化1$ git init 选择我们所需要创建/管理的git文件夹进行初始化，如图： 查看初始化过后的文件夹 我们可以手动去磁盘管理里面进行查看是否隐藏文件夹或者利用git的ls -a 去查看，如图： Git工作区，暂存区和版本库 托管平台： 局域网(内网) gitlab 公网(外网) Gitlab Github gitee 四：添加暂存区 添加暂存区: 1$ git add test.txt 查看暂存区的状态: 12345678$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: test.txt 将上传到暂存区的文件删除: 1$ git rm --cached 文件名 将工作区的全部文件上传到暂存区: 1$ git add . 五：提交到本地库 将暂存区代码提交到本地仓库中: 1$ git commit -m &quot;填写注释内容&quot; 当我们在此使用git status 查看时有“clean”关键字即代表暂存区无内容 123$ git statusOn branch masternothing to commit, working tree clean 查看提交的历史记录: 12345678910111213$ git logcommit 2e6ab1b4eb40dc5b70a06e971c72d7beaf3b3e42 (HEAD -&gt; master)Author: Poluk &lt;Poluk2001@163.com&gt;Date: Sat Nov 12 23:29:59 2022 +0800 这是第二次提交commit 6f84ca758c44b7405337818e8b53c71bc7412e53Author: Poluk &lt;Poluk2001@163.com&gt;Date: Sat Nov 12 23:01:12 2022 +0800 这是第一次提交 六：回退版本利用reset回退版本 回退到上一次提交的版本: 12$ git reset --hard HEAD^HEAD is now at 6f84ca7 这是第一次提交 回退到上上次提交的版本: 12$ git reset --hard HEAD~2$ git reset --hard HEAD ^^ 查看所有操作记录: 1234$ git reflog6f84ca7 (HEAD -&gt; master) HEAD@{0}: reset: moving to HEAD^2e6ab1b HEAD@{1}: commit: 这是第二次提交6f84ca7 (HEAD -&gt; master) HEAD@{2}: commit (initial): 这是第一次提交 根据commit id信息回退版本: 1$ git reset --hard commit id 如图： 回退版本到暂存区: 1$ git reset --soft commit id hard和soft回退版本的区别: soft功能作用： 重新写“提交记录” 把已提交到master的文件回退到暂存区，并且把新修改过后的同一个文件add到暂存区合并，一起再提交到master中，这样日志中就只有一个同文件的提交记录了。 利用revert回退版本 revert回退方式 1$ git revert head git reset: 是回滚到对应的commit-id,相当于是删除了commit-id以后的所有的提交，并且不会产生新的commit-id记录，如果要推送到远程服务器的话，需要强制推送-f git revert: 是反做撤销其中的commit-id,然后重新生成一个commit-id。 本身不会对其他的提交commit-id产生影响，如果要推送到远程服务器的话,就是普通的操作git push就好了 PS: reset –hard 和 revert 都会退回到工作区，但是revert是创建一个新的commit id 并且HEAD指针指向新生成的id，而reset –hard是删除当前commit id并且 HEAD指针直接指向上一个id 七：分支 查看分支(星号代表当前所在的分支): 12$ git branch* master 创建分支: 1$ git branch 分支名 切换分支: 12$ git checkout 分支名Switched to branch '分支名' 合并分支: 1$ git merge 分支名 删除分支: 合并完分支后，先切换到别的分支在进行删除操作： 12$ git branch -d 分支名Deleted branch newlist (was f667656). 合并冲突: 我们在不同的分支表示不同的工作区，分别在不同的分支上进行add和commit最终的文件内容也会因为分支不同而导致内容不同。 解决合并冲突就是git也不知道保留哪个内容或者都需要保留，所以需要我们手动解决合并冲突。 示意图： 八：添加远程仓库的地址 创建远程仓库地址: 添加远程仓库的地址: 1234567891011$ git remote add origin git@github.com:Github用户名/仓库名.git#范例如下:$ git remote add origin git@github.com:Poluk2001/testgit.git```````git remote add` 是命令，`origin` 是远程仓库名字，这是Git默认的叫法，也可以改成别的。3. **查看远程仓库名:**```shell$ git remote -v 移除远程仓库名: 1$ git remote remove origin 将本地仓库推送到远程仓库: 1$ git push -u origin master git push 是推送到远程仓库命令，-u 是记录当前地址，下次直接输入git push 命令即可； 拉取远程最新仓库: 1$ git pull #origin master origin master 可以不用写进去，所以这里我加了#，因为在之前默认使用-u 选项，所以git会自动识别我们之前默认的仓库名以及分支。 将远程仓库克隆到本地: 1$ git clone git@github.com:Poluk2001/testgit.git(仓库地址) 九：团队协作与冲突 添加协作者的Github账户: 用户可以有拉取和克隆远程仓库的权限，但是推送权限只有仓库创建者所拥有，我们需要在远程仓库的setting中添加合作者： 点击左侧Collaboratos 点击Add people 搜索需要添加合作的Github用户 将生成的Pending Invite发送给需要的协作的用户，对方进行点击即可，即可完成合作邀请操作 合并冲突: 在与团队协作当中我们会时常遇到合并冲突，我们需要与另一个人进行沟通，进行手动合并 在每次写代码之前，我们都要使用git pull命令来拉取仓库最新地址，保证我们本地仓库代码与远程仓库代码一致。 将本地仓库的分支推送到远程仓库: 1$ git push origin 本地分支名:远程分支名 将远程仓库分支拉取到本地仓库: 1$ git pull origin 远程分支名 删除远程仓库的分支: 1$ git push origin :远程分支名 十：跨团队协作","link":"/2022/10/share-git.html"},{"title":"二叉树的刷题笔记","text":"最近在代码随想录上学习各种算法并做了一些记录 二叉树的种类在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。 满二叉树定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。 也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。 如图： 完全二叉树定义：完全二叉树是由满二叉树而引出来的，对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 如图： 二叉搜索树定义：二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(logn) 。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。 如图： 平衡二叉搜索树定义：平衡二叉搜索树（英语：Balanced Binary Search Tree）是一种结构平衡的二叉搜索树，它是一种每个节点的左右两子树高度差都不超过1的二叉树。它能在 O(logn) 内完成插入、查找和删除操作，最早被发明的平衡二叉搜索树为AVL树 常见的平衡二叉搜索树有： AVL树 红黑树 如图： 最后一棵树左子树高度为2，右子树高度为0，高度差的绝对值大于1了 二叉树的存储方式二叉树可以链式存储，也可以顺序存储。 那么链式存储方式就用指针， 顺序存储的方式就是用数组。 顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。 链式存储如图： 顺序存储如图： 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 二叉树的遍历方式二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历：一层一层的去遍历。 层次遍历（迭代法） 这两种遍历是图论中最基本的两种遍历方式 做二叉树相关题目时，我们经常使用递归方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。 栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。 而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树的定义123456789101112public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }} 二叉树的深度优先遍历递归法对应LeetCode的题目： 144.二叉树的前序遍历 145.二叉树的后序遍历 94.二叉树的中序遍历 如果对递归不清楚的可以先去看一段视频了解一下：递归函数 写递归的三要素： 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 以前序遍历为例： 确定递归函数的参数和返回值，因为要打印出前序遍历节点的数值，所以参数里需要传入List来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下： 1public void preorder(TreeNode root, List&lt;Integer&gt; result) 确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下： 1if(root == null) {return;} 确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下： 123result.add(root.val);preorder(root.left, result);preorder(root.right, result); Tips：前中序遍历需将result.add(root.val)写到正确的位置 前序遍历1234567891011121314151617// 前序遍历·递归·LC144_二叉树的前序遍历class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); preorder(root, result); return result; } public void preorder(TreeNode root, List&lt;Integer&gt; result) { if (root == null) { return; } result.add(root.val); preorder(root.left, result); preorder(root.right, result); }} 中序遍历1234567891011121314151617// 中序遍历·递归·LC94_二叉树的中序遍历class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); inorder(root, res); return res; } void inorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } inorder(root.left, list); list.add(root.val); // 注意这一句 inorder(root.right, list); }} 后序遍历1234567891011121314151617// 后序遍历·递归·LC145_二叉树的后序遍历class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); postorder(root, res); return res; } void postorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } postorder(root.left, list); postorder(root.right, list); list.add(root.val); // 注意这一句 }} 迭代法对应LeetCode的题目： 144.二叉树的前序遍历 145.二叉树的后序遍历 94.二叉树的中序遍历 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。 前序遍历前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子，这样出栈的时候才是中左右的顺序。 动画示意如下： 代码如下： 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { //建List用来存放栈弹出的结果 List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(root == null) return result; //建栈 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //将根节点root入栈 stack.push(root); while(!stack.isEmpty()){ //将出栈的值用node记录下来，并保存到result中 TreeNode node = stack.pop(); result.add(node.val); //判断被记录的node右子树值是否为空,将此节点的右子树的值入栈 if(node.right != null) stack.push(node.right); //同右子树逻辑一样 if(node.left != null) stack.push(node.left); } return result; }} 中序遍历为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作： 处理：将元素放进result数组中 访问：遍历节点 分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。 动画示意如下： 12345678910111213141516171819202122class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ //用来访问最底层 if (cur != null){ //将访问的节点放入栈中 stack.push(cur); cur = cur.left; //左 }else{ //从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） cur = stack.pop(); result.add(cur.val); //中 cur = cur.right; //右 } } return result; }} 后序遍历后序遍历与前序遍历的关系： 前序遍历：中左右 后序遍历：左右中 如果从前序遍历得到后序遍历，首先调换前序遍历的左，右的位置，得到中，右，左，然后再翻转，得到左，右，中。 123456789101112131415161718192021222324class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { //建List用来存放栈弹出的结果 List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(root == null){ return result; } //建栈 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //将根节点root入栈 stack.push(root); while(!stack.isEmpty()){ //将出栈的值用node记录下来，并保存到result中 TreeNode node = stack.pop(); result.add(node.val); //注意先左，后右 if(node.left != null) stack.push(node.left); if(node.right != null) stack.push(node.right); } //处理完后,结果集中的结果是中右左，对结果进行翻转后得到左右中 Collections.reverse(result); return result; }} 二叉树的广度优先遍历二叉树的层序遍历接下来我们再来介绍二叉树的另一种遍历方式：层序遍历。 102.二叉树的层序遍历力扣题目链接 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。 思路： 需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。 而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。 动画示意如下： 1234567891011121314151617181920212223242526272829class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){ //用一个二维数组来接受最终结果 List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //创建一个队列用来存放二叉树节点 Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); //判断是否为空 if(root == null) return resList; //将根节点入队 que.offer(root); while(!que.isEmpty()){ //创建数组来存放出队的值 List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); //记录队列的大小 int len = que.size(); //控制队列的大小从而来控制出队的数，达到同一层的数正确的记录到一个数组中 while(len &gt; 0){ TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if(tmpNode.left != null) que.offer(tmpNode.left); if(tmpNode.right != null) que.offer(tmpNode.right); //每出队一个值，队列大小-1， len--; } resList.add(itemList); } return resList; }} 107.二叉树的层次遍历 II力扣题目链接 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 思路： 相对于102.二叉树的层序遍历，就是最后把result数组反转一下就可以了。 1234567891011121314151617181920class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { // 利用链表可以进行 O(1) 头部插入, 这样最后答案不需要再反转 LinkedList&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); if(root != null) que.offer(root); while(!que.isEmpty()){ List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); int len = que.size(); for(int i = 0; i &lt; len; i++){ TreeNode node =que.poll(); temp.add(node.val); if(node.left != null) que.offer(node.left); if(node.right != null) que.offer(node.right); } ans.addFirst(temp); //将新遍历的结果插入到链表头部 } return ans; }} 199.二叉树的右视图力扣题目链接 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 思路： 层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。 12345678910111213141516171819class Solution { public List&lt;Integer&gt; rightSideView(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); if(root == null) return list; que.offer(root); while(!que.isEmpty()){ int levelSize = que.size(); for(int i = 0; i &lt; levelSize; i++){ TreeNode pollNode = que.poll(); //对栈的循环只将每层中的最后一个元素加入结果集就行，实在不理解可以画一个二叉树模拟一遍 if(i == levelSize - 1) list.add(pollNode.val); if(pollNode.left != null) que.offer(pollNode.left); if(pollNode.right != null) que.offer(pollNode.right); } } return list; }} 637.二叉树的层平均值力扣题目链接 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 思路: 本题就是层序遍历的时候把一层求个总和在取一个均值。 12345678910111213141516171819202122class Solution { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; list = new ArrayList&lt;Double&gt;(); Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); if(root == null) return list; que.offer(root); while(!que.isEmpty()){ int levelSize = que.size(); //定义一个double类型的变量存放每层的平均值 double levelSum = 0.0; for(int i = 0; i &lt; levelSize; i++){ TreeNode pollNode = que.poll(); //将弹出队列的元素加到变量中 levelSum += pollNode.val; if(pollNode.left != null) que.offer(pollNode.left); if(pollNode.right != null) que.offer(pollNode.right); } list.add(levelSum / levelSize); } return list; }} 429.N叉树的层序遍历力扣题目链接 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。 思路: 这道题依旧是模板题，只不过一个节点有多个孩子了 1234567891011121314151617181920class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); Queue&lt;Node&gt; que = new LinkedList&lt;&gt;(); if(root == null) return ans; que.offer(root); while(!que.isEmpty()){ int levelSize = que.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; levelSize; i++){ Node pollNode = que.poll(); //将从队列弹出的孩子节点依次入队 for(Node node : pollNode.children) que.offer(node); list.add(pollNode.val); } ans.add(list); } return ans; }} 515.在每个树行中找最大值力扣题目链接 您需要在二叉树的每一行中找到最大的值。 思路： 层序遍历，取每一层的最大值 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; largestValues(TreeNode root) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); if(root == null) return ans; que.offer(root); while(!que.isEmpty()){ int levelSize = que.size(); int levelMax = Integer.MIN_VALUE; for(int i = 0; i &lt; levelSize; i++){ TreeNode pollNode = que.poll(); //利用max函数判断levelMax的值和出队的值谁大 levelMax = Math.max(levelMax,pollNode.val); if(pollNode.left != null) que.offer(pollNode.left); if(pollNode.right != null) que.offer(pollNode.right); } ans.add(levelMax); } return ans; }} 116.填充每个节点的下一个右侧节点指针力扣题目链接 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 思路： 本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了 迭代： 12345678910111213141516class Solution { public Node connect(Node root) { if(root == null) return root; Deque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()){ int n = queue.size(); for(int i = 0; i &lt; n; i++){ Node node = queue.pop(); if(i != n-1) node.next = queue.peek(); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); } return root; }} 递归： 1234567891011121314151617181920212223class Solution { public Node connect(Node root) { if(root == null) return null; DFS(root); return root; } public void DFS(Node root){ //递归退出条件，需要用到父节点来操作.next指向右邻居，所以最后一次递归执行是当root到叶子结点的上一层对叶子结点进行操作 if(root.left == null || root.right == null){ return; } //root的左孩子肯定有右邻居 root.left.next = root.right; //如果父亲节点有右邻居，那么父节点root的右孩子一定也有右邻居 if(root.next != null){ root.right.next = root.next.left; } //前序遍历 DFS(root.left); DFS(root.right); }} 117.填充每个节点的下一个右侧节点指针II力扣题目链接 思路： 这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道 12345678910111213141516class Solution { public Node connect(Node root) { if(root == null) return root; Deque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()){ int n = queue.size(); for(int i = 0; i &lt; n; i++){ Node node = queue.pop(); if(i != n-1) node.next = queue.peek(); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); } return root; }} 104.二叉树的最大深度力扣题目链接 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 思路： 使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。 在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示： 递归： 12345678910111213class Solution { public int maxDepth(TreeNode root) { if(root == null){ return 0; } //计算左子树深度 int leftHight = maxDepth(root.left); //计算右子树深度 int rightHight = maxDepth(root.right); //从左子树和右子树深度中选一个最大的值和当前节点+1，并且返回maxHight return Math.max(leftHight,rightHight) + 1; }} 迭代： 123456789101112131415161718class Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int depth = 0; while(!queue.isEmpty()){ int size = queue.size(); for(int i = 0; i &lt; size; i++){ TreeNode pollNode = queue.poll(); if(pollNode.left != null) queue.offer(pollNode.left); if(pollNode.right != null) queue.offer(pollNode.right); } depth++; } return depth; }} 111.二叉树的最小深度力扣题目链接 相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。 需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点 1234567891011121314151617181920class Solution { public int minDepth(TreeNode root) { if(root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int depth = 0; while(!queue.isEmpty()){ int size = queue.size(); depth++; for(int i = 0; i &lt; size; i++){ TreeNode pollNode = queue.poll(); //如果当前节点的左右孩子都为空，直接返回最小深度 if(pollNode.left == null &amp;&amp; pollNode.right == null) return depth; if(pollNode.left != null) queue.offer(pollNode.left); if(pollNode.right != null) queue.offer(pollNode.right); } } return depth; }}","link":"/2023/05/share-BinaryTree.html"},{"title":"分享一点自己在 B 站收藏的“比较有质量”的课程","text":"随便说一点 我自己在日常会整理、收藏一些比较有质量的课程，特别想分享在这里，分享给有需要的人！。 本次就是纯分享一些大家日常所能看到的推荐列表里没有的课程，比如CS自学指南大部分列表里没有的课程，CS自学指南的课程确实都是高质量的公开课，不过课程难度，英语水平可能是看这些课的障碍，比如我这个菜狗，英文也是一大障碍(在弥补中)。 我分享的列表课程并不能代替那些质量公开课，有能力的还是尽量去听CS自学指南推荐的课。每个人水平不同，而且我分享的列表中也有一些985大学在校生讲的而且讲的非常不错，我只是分享出来，帮助有需要和有需求的人。 国内的公开课数量和质量也在大大增加，比如南京大学的几位老师近几年都在平台上分享自己的课程实录，甚至上课的时候同时开直播，与南大学子一起上课。 本来也想整理一些有质量的Up主的，但是我的账号关注数有一点小多，暂时就不整理分享了。如果各位大佬有推荐的UP,以及质量课程可以发在评论区一起交流。收藏不等于学会，同时也祝我们国内更好的课程越来越多。 第一次在这里做分享，本人比较菜，有些课程分类可能不正确，但是尽力了，希望各位轻喷！ 操作系统/计算机组成 操作系统实现 操作系统速成-2022秋冬朋辈辅学录播 CSAPP-深入理解计算机系统-讲解 “一生一芯” MIT6.828/6.S081操作系统课程教程 从零开始自制操作系统 2023 南京大学 “操作系统：设计与实现” (蒋炎岩) 厦门大学-操作系统原理（2022春） 现代操作系统：原理与实现（上海交通大学） 【操作系统原理】清华大学陈渝教授 深入理解计算机系统—个人讲解 深入理解计算机系统-CSAPP重点导读 Dr.Dng陪跑CSAPP: bigONE《深入理解计算机系统》 CS162操作系统-精译(更新中) 台湾清华大学 - 操作系统 Operating Systems - 黄能富教授 编译相关/软件分析 南京大学《软件分析》课程2020 手写一个 RISC-V 编译器！初学者友好的实战课程 南京大学软件学院编译原理课程 数据结构/算法相关 东北大学：2021～2022春季学期算法设计与分析 南京大学《2023算法设计与分析》- 黄宇 南京大学《2023算法设计与分析》- 徐经纬 数据结构与算法基础（青岛大学-王卓） 跟懒猫老师快乐学数据结构 计算机网络 计算机网络-通熟易懂讲解每个知识要点 中科大郑烇、杨坚全套-计算机网络（自顶向下方法) 计算机网络微课堂 程序语言/编程语言 计算机程序的构造与解释（SICP, Python版） 计算机语言 x86汇编语言：从实模式到保护模式（操作系统引导课） 程序语言理论与实现 【CS公开课】计算机程序的构造和解释（SICP） 精译-UC Berkeley 公开课-CS61A【计算机程序的构造和解释】 (Spring 2021) 软件工程 南京大学-2023软件工程与计算 I 数据库 数据库系统（DBMS） CMU15-445-精译(更新中) 并行程序设计 并行程序设计 谭光明 高性能并行编程与优化 新竹清华大学：并行计算与并行编程课程 工具 浙江大学：「实用技能拾遗」2023 春夏朋辈辅学 Obsidian公开课 不会分类的or列表太少不至于分类的 硬件茶谈：硬核科普 精读c++primer 计算机图形学游戏方向-2023年春季第2次迭代-谭剑 Linux 文件系统九讲-陈硕 DDIA 读书逐章分享 机器学习-白板推导系列 陈明-南京大学23春-面向对象编程基础 每个程序员都应该知道的内存知识 (带你走读Ulrich Drepper的经典论文) Linux 操作系统 核心設計 ||完结","link":"/2023/04/share-bilibili.html"},{"title":"加缪获颁诺贝尔文学奖致谢辞(中法)","text":"Sire, Madame, Altesses Royales, Mesdames, Messieurs, 国王陛下，王后，各位殿下，女士们、先生们， En recevant la distinction dont votre libre Académie a bien voulu m’honorer, ma gratitude était d’autant plus profonde que je mesurais à quel point cette récompense dépassait mes mérites personnels. 秉承自由精神的瑞典皇家科学院将这份殊荣授予我，万分感激之余更添万般惶愧。 Tout homme et, à plus forte raison, tout artiste, désire être reconnu. Je le désire aussi. Mais il ne m’a pas été possible d’apprendre votre décision sans comparer son retentissement à ce que je suis réellement. 再理智的人，再理智的艺术家，都渴望被认可。我也不例外。但比起自己所做的一切，这份殊荣是过于沉重了。 Comment un homme presque jeune, riche de ses seuls doutes et d’une œuvre encore en chantier, habitué à vivre dans la solitude du travail ou dans les retraites de l’amitié, n’aurait-il pas appris avec une sorte de panique un arrêt qui le portait d’un coup, seul et réduit à lui-même, au centre d’une lumière crue ? De quel cœur aussi pouvait-il recevoir cet honneur à l’heure où, en Europe, d’autres écrivains, parmi les plus grands, sont réduits au silence, et dans le temps même où sa terre natale connaît un malheur incessant ? 一个年届不惑却依然满怀困惑的人，创作生涯正值中途，习惯远离朋友、孤独劳作，突然被拦下脚步、推至聚光灯下，四顾无援的他怎能不惊慌失措？他将藉着怎样的心情来接受这份荣耀？此时此刻，就在欧洲，有许多作家，甚至是最伟大的作家，依然默默无闻、乏人问津；此时此刻，就在我出生的地方，依然不幸接连着不幸。 J’ai connu ce désarroi et ce trouble intérieur. Pour retrouver la paix, il m’a fallu, en somme, me mettre en règle avec un sort trop généreux. Et, puisque je ne pouvais m’égaler à lui en m’appuyant sur mes seuls mérites, je n’ai rien trouvé d’autre pour m’aider que ce qui m’a soutenu tout au long de ma vie, et dans les circonstances les plus contraires : l’idée que je me fais de mon art et du rôle de l’écrivain. Permettez seulement que, dans un sentiment de reconnaissance et d’amitié, je vous dise, aussi simplement que je le pourrai, quelle est cette idée. 这样的惶惑不安与内心焦灼于我并不陌生。面对命运的过度垂青，想要重归平静，唯有力求问心无愧。既然我所做的一切与此盛誉颇不相称，别无他法，只有拿一生中最险恶的逆境下支撑我的信念来应对：对艺术的信念，对作家这一角色的信念。借此机会，怀着感激和友善之情，敬请诸位允许我用最简约的方式来阐释这两种信念 Je ne puis vivre personnellement sans mon art. Mais je n’ai jamais placé cet art au-dessus de tout. S’il m’est nécessaire au contraire, c’est qu’il ne se sépare de personne et me permet de vivre, tel que je suis, au niveau de tous. 没有艺术，我的生命将不复存在。但我从不将这艺术至于一切之上。如果说艺术对我而言不可或缺，那是因为它决不自我孤立，在与他人同等的层面上，让我本色地活下去。 L’art n’est pas à mes yeux une réjouissance solitaire. Il est un moyen d’émouvoir le plus grand nombre d’hommes en leur offrant une image privilégiée des souffrances et des joies communes. 我觉得艺术不应是独自享受，而是一种方法，用它来感动最大多数的人，向他们奉献一种超乎苦痛和普通欢愉之上的形象。 Il oblige donc l’artiste à ne pas se séparer ; il le soumet à la vérité la plus humble et la plus universelle. Et celui qui, souvent, a choisi son destin d’artiste parce qu’il se sentait différent apprend bien vite qu’il ne nourrira son art, et sa différence, qu’en avouant sa ressemblance avec tous. 它迫使艺术家不再自我孤立，让他臣服于最卑微、最普遍的真理。通常情况下，选择献身艺术的人，都曾自视与众不同。然而他很快会发现，自己的艺术、自己的与众不同，往往就扎根在与所有人的相似中。 L’artiste se forge dans cet aller retour perpétuel de lui aux autres, à mi-chemin de la beauté dont il ne peut se passer et de la communauté à laquelle il ne peut s’arracher. C’est pourquoi les vrais artistes ne méprisent rien ; ils s’obligent à comprendre au lieu de juger. Et s’ils ont un parti à prendre en ce monde ce ne peut être que celui d’une société où, selon le grand mot de Nietzsche, ne règnera plus le juge, mais le créateur, qu’il soit travailleur ou intellectuel. 艺术家就是在自我与他者不断的交往中、在半途不可错过的美景中、在无法抽离的群体中慢慢锤炼自己的。因此，真正的艺术家看重一切，他们逼迫自己去理解，而不仅仅满足当个评判。在这世上，他们必须选择一个阵营，那一定是代表某一集团的立场，据尼采的伟大洞见，在这个集团中，占统治地位的不是判官，而是创造者，他们之中既有劳动者，也有知识分子。 Le rôle de l’écrivain, du même coup, ne se sépare pas de devoirs difficiles. Par définition, il ne peut se mettre aujourd’hui au service de ceux qui font l’histoire : il est au service de ceux qui la subissent. 再来谈谈作家的角色，同样责任重大。确切地说，今天的作家不应为制造历史的人服务，而要为承受历史的人服务。 Ou sinon, le voici seul et privé de son art. Toutes les armées de la tyrannie avec leurs millions d’hommes ne l’enlèveront pas à la solitude, même et surtout s’il consent à prendre leur pas. 否则，他将形影相吊，远离真正的艺术。任何暴君的千百万军队都无法将一个作家从孤独中拯救出来，尤其当这个作家同他们的步调一致的时候。 Mais le silence d’un prisonnier inconnu, abandonné aux humiliations à l’autre bout du monde, suffit à retirer l’écrivain de l’exil chaque fois, du moins, qu’il parvient, au milieu des privilèges de la liberté, à ne pas oublier ce silence, et à le relayer pour le faire retentir par les moyens de l’art. 相反，一个无名囚徒的沉默，一个被遗弃在世界另一个角落百般受辱的囚徒，就足以将作家从流放中召回，就算这个作家身处优境，只要他不忘记这种沉默，用艺术的种种方式来彰表这种沉默。 Aucun de nous n’est assez grand pour une pareille vocation. Mais dans toutes les circonstances de sa vie, obscur ou provisoirement célèbre, jeté dans les fers de la tyrannie ou libre pour un temps de s’exprimer, l’écrivain peut retrouver le sentiment d’une communauté vivante qui le justifiera, à la seule condition qu’il accepte, autant qu’il peut, les deux charges qui font la grandeur de son métier : le service de la vérité et celui de la liberté. 我们之中没有一个人能强大到不负这一使命。但在作家漫长一生的境遇中，晦暗也好，腾达也好，在暴君的铁牢中也好，能自在发出声音时也好，只要他尽力做到为真理服务，为自由服务，他就能重新找回勃勃而富有生机的集体情感和支撑。为真理服务，为自由服务，这两条也足以体现作家职业的伟大。 Puisque sa vocation est de réunir le plus grand nombre d’hommes possible, elle ne peut s’accommoder du mensonge et de la servitude qui, là où ils règnent, font proliférer les solitudes. Quelles que soient nos infirmités personnelles, la noblesse de notre métier s’enracinera toujours dans deux engagements difficiles à maintenir : le refus de mentir sur ce que l’on sait et la résistance à l’oppression. 既然作家的使命是团结尽可能多的人，那就只有容忍谎言和奴性。这个世界充斥着谎言和奴性，孤独的荒草到处疯长。无论我们每个人有怎样的弱点，作家职业的高贵永远植根在两种艰难的介入中：拒绝谎言，反抗逼迫。 Pendant plus de vingt ans d’une histoire démentielle, perdu sans secours, comme tous les hommes de mon âge, dans les convulsions du temps, j’ai été soutenu ainsi : par le sentiment obscur qu’écrire était aujourd’hui un honneur, parce que cet acte obligeait, et obligeait à ne pas écrire seulement. Il m’obligeait particulièrement à porter, tel que j’étais et selon mes forces, avec tous ceux qui vivaient la même histoire, le malheur et l’espérance que nous partagions. Ces hommes, nés au début de la première guerre mondiale, qui ont eu vingt ans au moment où s’installaient à la fois le pouvoir hitlérien et les premiers procès révolutionnaires, qui furent confrontés ensuite, pour parfaire leur éducation, à la guerre d’Espagne, à la deuxième guerre mondiale, à l’univers concentrationnaire, à l’Europe de la torture et des prisons, doivent aujourd’hui élever leurs fils et leurs œuvres dans un monde menacé de destruction nucléaire. Personne, je suppose, ne peut leur demander d’être optimistes. 二十多年荒唐的历史进程中，我茫然无助，和许多同龄人一样，在时代的剧烈动荡中，仅靠一种情感模模糊糊地支撑自己：写作的光荣。写作之所以光荣，是因为它有所承担，它承担的不仅仅是写作。它迫使我以自己的方式、凭自己的力量、和这个时代所有的人一起，承担我们共有的不幸和希望。这代人，生于一战之初；二十来岁时伴随早期的工业革命进程，又遭遇希特勒的暴政；随后，仿佛要让他们的经历更完美，发生了西班牙战争、二战、集中营惨剧，整个欧洲满目苍夷、狱祸四起；如今，他们又不得不在核毁灭的阴影下哺育子嗣、成就事业。没人能要求他们更乐观。 Et je suis même d’avis que nous devons comprendre, sans cesser de lutter contre eux, l’erreur de ceux qui, par une surenchère de désespoir, ont revendiqué le droit au déshonneur, et se sont rués dans les nihilismes de l’époque. Mais il reste que la plupart d’entre nous, dans mon pays et en Europe, ont refusé ce nihilisme et se sont mis à la recherche d’une légitimité. Il leur a fallu se forger un art de vivre par temps de catastrophe, pour naître une seconde fois, et lutter ensuite, à visage découvert, contre l’instinct de mort à l’œuvre dans notre histoire. 我甚至主张在与之斗争的同时，要理解他们的错误。他们只是因为过度绝望才行不智之举，对时代的虚无主义趋之若鹜。但终究我们中的大多数，不止是在我国，也在整个欧洲，都拒绝这样的虚无主义，致力于追寻合法性。我们需要锻造一种灾难时代生活的艺术，以全新的面貌获得再生，与历史生涯中死亡的本能作斗争。 Chaque génération, sans doute, se croit vouée à refaire le monde. La mienne sait pourtant qu’elle ne le refera pas. 或许，每一代人都自负能重构这个世界。而我们这一代人却明白这是痴人说梦。 Mais sa tâche est peut-être plus grande. Elle consiste à empêcher que le monde se défasse. Héritière d’une histoire corrompue où se mêlent les révolutions déchues, les techniques devenues folles, les dieux morts et les idéologies exténuées, où de médiocres pouvoirs peuvent aujourd’hui tout détruire mais ne savent plus convaincre, où l’intelligence s’est abaissée jusqu’à se faire la servante de la haine et de l’oppression, cette génération a dû, en elle-même et autour d’elle, restaurer, à partir de ses seules négations, un peu de ce qui fait la dignité de vivre et de mourir. 但我们的使命也许更伟大，那就是要防止这个世界分崩离析。这一代人继承的历史是腐化的，混杂着失败的革命、疯狂的技术、死去的神祇和疲弱的意识形态。在这样的历史之中，政权能摧毁今天的一切，却并不能说服，智者自贬身价成为了仇视和压迫的奴役。这代人不得不带着独有的清醒，为自身和周围修复一点点生存和死亡的尊严。 Devant un monde menacé de désintégration, où nos grands inquisiteurs risquent d’établir pour toujours les royaumes de la mort, elle sait qu’elle devrait, dans une sorte de course folle contre la montre, restaurer entre les nations une paix qui ne soit pas celle de la servitude, réconcilier à nouveau travail et culture, et refaire avec tous les hommes une arche d’alliance. Il n’est pas sûr qu’elle puisse jamais accomplir cette tâche immense, mais il est sûr que partout dans le monde, elle tient déjà son double pari de vérité et de liberté, et, à l’occasion, sait mourir sans haine pour lui. C’est elle qui mérite d’être saluée et encouragée partout où elle se trouve, et surtout là où elle se sacrifie. C’est sur elle, en tout cas, que, certain de votre accord profond, je voudrais reporter l’honneur que vous venez de me faire. 在这个即将分崩离析的世界面前，审查官建立的恐怕是永久死亡的国度。这代人明白，在与时间疯狂赛跑的同时，他们应在不同民族间建立不屈于任何强权的和平，调和劳作与文化的关系，在每个人心里重建和解的桥梁。能否完成这一使命还是未知数，但在世界各处，他们祭起真理和自由的大旗，必要时，愿意为此牺牲而无怨无悔。这一代人在哪里都值得敬重、值得鼓励，尤其是在他们献身的地方。总之，应该是向他们，献上你们刚刚赋予我的荣耀，我想你们也会深有同感。 Du même coup, après avoir dit la noblesse du métier d’écrire, j’aurais remis l’écrivain à sa vraie place, n’ayant d’autres titres que ceux qu’il partage avec ses compagnons de lutte, vulnérable mais entêté, injuste et passionné de justice, construisant son œuvre sans honte ni orgueil à la vue de tous, sans cesse partagé entre la douleur et la beauté, et voué enfin à tirer de son être double les créations qu’il essaie obstinément d’édifier dans le mouvement destructeur de l’histoire. 阐述完作家职业的高贵，我还想藉此机会谈谈作家的本职。除了战斗者他们没有其他头衔，他们脆弱却执着，虽得不到公正却向往公正，众目睽睽之下不卑不亢地构思，永远在痛苦与美好之间徘徊，在历史毁灭性的运动中以及其自身双重的存在里，抽丝剥茧般最终完成自己的创造。 Qui, après cela, pourrait attendre de lui des solutions toutes faites et de belles morales ? La vérité est mystérieuse, fuyante, toujours à conquérir. La liberté est dangereuse, dure à vivre autant qu’exaltante. Nous devons marcher vers ces deux buts, péniblement, mais résolument, certains d’avance de nos défaillances sur un si long chemin. 除此之外，谁又能指望从作家那里得到现成的答案和美丽的道德信条呢？真理是难以捉摸、稍纵即逝、永远有待追逐的。自由之路险境重重、难以生存却又令人振奋。我们必须朝着真理和自由的目标前进，艰苦卓绝却坚定不移，路漫漫却要勇往直前。 Quel écrivain, dès lors oserait, dans la bonne conscience, se faire prêcheur de vertu ? Quant à moi, il me faut dire une fois de plus que je ne suis rien de tout cela. Je n’ai jamais pu renoncer à la lumière, au bonheur d’être, à la vie libre où j’ai grandi. 从此，哪个有着自知之明的作家还敢自诩为道德说教者？至于我本人，再次重申，我绝不扮演这样的角色。我从不曾放弃过追求光明，感受存在的幸福，向往少年时自由自在的生活。 Mais bien que cette nostalgie explique beaucoup de mes erreurs et de mes fautes, elle m’a aidé sans doute à mieux comprendre mon métier, elle m’aide encore à me tenir, aveuglément, auprès de tous ces hommes silencieux qui ne supportent, dans le monde, la vie qui leur est faite que par le souvenir ou le retour de brefs et libres bonheurs. 这种种贪恋之情尽管也让我犯了不少错误，却也帮助我更好地理解了我的职业，支持我不假思索地站在那些沉默者一边。对他们而言，要在这世上活下去，唯有靠那一点点幸福、自由却又短暂的回忆。 Ramené ainsi à ce que je suis réellement, à mes limites, à mes dettes, comme à ma foi difficile, je me sens plus libre de vous montrer pour finir, l’étendue et la générosité de la distinction que vous venez de m’accorder, plus libre de vous dire aussi que je voudrais la recevoir comme un hommage rendu à tous ceux qui, partageant le même combat, n’en ont reçu aucun privilège, mais ont connu au contraire malheur et persécution. 由此回到现实中的我，回到我的局限、我的债务，回到我艰难的信仰上来。作为结束，我感到能更坦然地向诸位表达我的情意。这份殊荣，我愿意接受并与所有同我一起战斗的人分享，他们从未得到过任何一点奖赏，却唯独受尽了折磨与不幸。 Il me restera alors à vous en remercier, du fond du cœur, et à vous faire publiquement, en témoignage personnel de gratitude, la même et ancienne promesse de fidélité que chaque artiste vrai, chaque jour, se fait à lui-même, dans le silence. 最后，请再次接受我发自内心的感激和公开忠诚的承诺。这一古老而忠诚的承诺，是每一个真正的艺术家每天面对自己默默必行的功课。","link":"/2023/06/Albert-Camus-NobelTalk.html"},{"title":"简易的生存手册","text":"","link":"/2023/09/SelfExperience.html"},{"title":"记录一下最近的思绪","text":"最近思绪很多所以想把这些记录一下。 这学期开学来时常会有焦虑，心情一直在焦虑和平静中起伏。本来这学期是计划找实习，这样能在工业界里学到更多的相关知识，总比待在学习里好。但是在BOSS上，里面大多都是投了无数多的简历并且连个面试的机会都没有的帖子，这只会让我更焦躁。看了招聘条件后总觉得自己还是差点东西才能胜任这份实习，尽管对实习生其实并不需要多高的技能水平。鉴于这样的情况，我暂时还是打消了找实习的念头，打算花更多的时间再提升一下技能水平。 最近因为学习算法中遇到了一些问题，又开始有些焦躁。在过去两年中每次在接触并且学习新东西的时候会产生各种的迷茫，也许对我来说没办法，自学总是不弯弯绕绕很难走到正确的路。很遗憾大一的时候自己的认知和视野没有照到相对正确的路上，导致了一些时间花在学习变化很快的主流技术上面，没有从计算机基础开始。 其实我喜欢计算机相关，也愿意从事这份工作，但并不想做一个简单的CRUD开发者，想在一个喜欢的领域里贡献自己那份仅有的价值。也许期望太高了？这只不过是个最终理想罢了。我总是为项目里需要用到的技能而去学某些东西，但是学完之后从未觉得它们被我拥有过，只是单纯的拿它们用来服务所需的项目里，从来没想过自己能用它们做一些自己觉得有意思的事情，这是我意识到自己所缺的那部分。 一直觉得焦虑是可以有的，但是不能长期焦虑影响到自己的生活。与其不停的让自己处于焦虑中，倒不如提升自己，多做事情，让自己在未来的日子里能施展能力的概率更大一点。 在经济下行的环境中，个人的努力显得微不足道，我也做好了“尽管学再多的技术也找不到工作”的心里准备。也庆幸自己在不好的环境中还可以通过互联网认识到了诸多的优秀开发者，同样也可以看到世界级名校的公开课，从优秀的开发者中学到了很多并且得到了受益的建议与鼓励。他们如此谦逊并且愿意分享自己的经验给陌生人，也许这个群体受益于开源的思想吧。 在大学两年最能影响到我的是Ray-Eldath，在3月底最焦虑和迷茫的日子里我写信给他寻求职业发展的建议，这也是我第一次以长文的形式写信给别人，虽然文笔并不是很好，但是我尽量的表达清楚。而在他的回信中我感到他的文字充满力量并不禁感叹文笔如此的好，翻过他的博客我知道这一定离不开他本人拥有浓厚的文学知识。 在回信中让重新对以后充满期望的一句话就是：“‘人灵魂的欲望是其命运的先知’，每当在埋头苦读中感到疲乏、有退缩之意时，我总在心中默念这个句子，因为坚定而不屈的灵魂值得美好又光明的未来，他们在人群中熠熠生辉。我们要为成为那样的人而努力。” 之前还想过并且不止想过一次，在城市里工作感到真的真的疲惫的那时，那就选择一个喜欢的城市去经营一个自己喜欢的店铺(也许是苏州？)，我向往最好一点的生活也就是这样了。甚至还有个想法就是做海洋救助的公益，很难实现，但是我心里是想做，也许这也是一个终极理想吧？但这都是留给自己的“退路”。 大学这两年我也慢慢成为了知识的虔诚信徒，也明白知识是可贵的，虽然身处环境一般但敬畏知识。还算年轻，我还有很多喜欢的东西来支撑着我期许未来，很多很多喜欢的衣服还没有穿，被称之为“不夜城”的香港和“自由乌托邦”的阿姆斯特丹还没有去，有很多热爱和喜欢的事物还没有去接触。 想起Ray-Eldath在信中提到过一篇题为《拥抱苦差事》的文章中里引用的一句话：“如果某个魔术所需的时间、金钱或练习的次数，比你（或任何一个普通人）所愿意付出的更多，那你就会被骗到”。如果你愿意拥抱苦差事，你就可以完成不可能完成的任务，但愿我们在拥抱苦差事之后也可以被更多一点的幸运所眷顾，让我们去展示这些“魔法”。 写下这些也是想让自己在这段文字之后让自己重新期待未来，好好享受“暂时不用考虑社会里烦恼”的日子，安静的做自己喜欢的事情。","link":"/2023/05/share-myideas.html"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Share","slug":"Share","link":"/tags/Share/"},{"name":"Albert Camus","slug":"Albert-Camus","link":"/tags/Albert-Camus/"},{"name":"Biography","slug":"Biography","link":"/tags/Biography/"},{"name":"Self","slug":"Self","link":"/tags/Self/"},{"name":"Advice","slug":"Advice","link":"/tags/Advice/"},{"name":"Life","slug":"Life","link":"/tags/Life/"}],"categories":[{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Article","slug":"Article","link":"/categories/Article/"},{"name":"Daily","slug":"Daily","link":"/categories/Daily/"}],"pages":[{"title":"About","text":"关于Poluk计算机相关专业在校生。目前主要在后端开发领域学习，也正在探索自己其他比较感兴趣的方向。 喜欢的：艺术，时装，美学，赛车，美剧，纪录片，多类风格的音乐，偶尔看看番剧，不过更倾向于看小众番和旧番。 很热爱这个世界也希望这个世界可以更好。 未完…","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}