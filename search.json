[{"title":"一份简短的Git学习记录","url":"/2022/10/share-git.html","content":"一：Git介绍\nGit是免费的开源软件，用于分布式版本控制：跟踪任何一组文件的变化，通常用于协调软件开发过程中合作开发源代码的程序员之间的工作。它的目标包括速度、数据完整性和对分布式、非线性工作流程的支持（在不同系统上运行的数千个并行分支）。\n\n\n\n版本控制  版本控制(Revision control)是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。\n团队协作  从单兵作战转换为团队作战\n\n二：Git的安装Git官网：Git官网Git安装教程：安装教程\n安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：\n$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com\n\n三：初始化$ git init\n\n\n选择我们所需要创建&#x2F;管理的git文件夹进行初始化，如图：\n\n\n\n查看初始化过后的文件夹\n\n我们可以手动去磁盘管理里面进行查看是否隐藏文件夹或者利用git的ls -a 去查看，如图：\n\n\nGit工作区，暂存区和版本库\n\n\n托管平台：\n\n局域网(内网)\ngitlab\n\n\n公网(外网)\nGitlab\nGithub\ngitee\n\n\n\n四：添加暂存区\n添加暂存区:\n\n$ git add test.txt\n\n\n查看暂存区的状态:\n\n$ git statusOn branch masterNo commits yetChanges to be committed:  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)        new file:   test.txt\n\n\n将上传到暂存区的文件删除:\n\n$ git rm --cached 文件名\n\n\n将工作区的全部文件上传到暂存区:\n\n$ git add .\n\n五：提交到本地库\n将暂存区代码提交到本地仓库中:\n\n$ git commit -m &quot;填写注释内容&quot;\n当我们在此使用git status 查看时有“clean”关键字即代表暂存区无内容\n$ git statusOn branch masternothing to commit, working tree clean\n\n\n查看提交的历史记录:\n\n$ git logcommit 2e6ab1b4eb40dc5b70a06e971c72d7beaf3b3e42 (HEAD -&gt; master)Author: Poluk &lt;Poluk2001@163.com&gt;Date:   Sat Nov 12 23:29:59 2022 +0800    这是第二次提交commit 6f84ca758c44b7405337818e8b53c71bc7412e53Author: Poluk &lt;Poluk2001@163.com&gt;Date:   Sat Nov 12 23:01:12 2022 +0800    这是第一次提交\n\n六：回退版本利用reset回退版本\n回退到上一次提交的版本:\n\n$ git reset --hard HEAD^HEAD is now at 6f84ca7 这是第一次提交\n\n\n回退到上上次提交的版本:\n\n$ git reset --hard HEAD~2$ git reset --hard HEAD ^^\n\n\n\n查看所有操作记录:\n\n$  git reflog6f84ca7 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^2e6ab1b HEAD@&#123;1&#125;: commit: 这是第二次提交6f84ca7 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): 这是第一次提交\n\n\n根据commit id信息回退版本:\n\n$ git reset --hard commit id\n\n如图：\n\n回退版本到暂存区:\n\n$ git reset --soft commit id\n\n\nhard和soft回退版本的区别:\n\n\n\nsoft功能作用：\n\n重新写“提交记录”\n把已提交到master的文件回退到暂存区，并且把新修改过后的同一个文件add到暂存区合并，一起再提交到master中，这样日志中就只有一个同文件的提交记录了。\n\n\n利用revert回退版本\nrevert回退方式\n\n$ git revert head\n\n\n\ngit reset: 是回滚到对应的commit-id,相当于是删除了commit-id以后的所有的提交，并且不会产生新的commit-id记录，如果要推送到远程服务器的话，需要强制推送-f\ngit revert: 是反做撤销其中的commit-id,然后重新生成一个commit-id。 本身不会对其他的提交commit-id产生影响，如果要推送到远程服务器的话,就是普通的操作git push就好了\nPS: reset –hard 和 revert 都会退回到工作区，但是revert是创建一个新的commit id 并且HEAD指针指向新生成的id，而reset –hard是删除当前commit id并且 HEAD指针直接指向上一个id\n\n七：分支\n查看分支(星号代表当前所在的分支):\n\n$ git branch* master\n\n\n创建分支:\n\n$ git branch 分支名\n\n\n切换分支:\n\n$ git checkout 分支名Switched to branch &#x27;分支名&#x27;\n\n\n合并分支:\n\n$ git merge 分支名\n\n\n删除分支:\n\n合并完分支后，先切换到别的分支在进行删除操作：\n$ git branch -d 分支名Deleted branch newlist (was f667656).\n\n\n合并冲突:\n  我们在不同的分支表示不同的工作区，分别在不同的分支上进行add和commit最终的文件内容也会因为分支不同而导致内容不同。  解决合并冲突就是git也不知道保留哪个内容或者都需要保留，所以需要我们手动解决合并冲突。\n\n\n示意图：\n八：添加远程仓库的地址\n创建远程仓库地址:\n\n\n\n添加远程仓库的地址:\n\n$ git remote add origin git@github.com:Github用户名/仓库名.git#范例如下:$ git remote add origin git@github.com:Poluk2001/testgit.git```````git remote add` 是命令，`origin` 是远程仓库名字，这是Git默认的叫法，也可以改成别的。3. **查看远程仓库名:**```shell$ git remote -v\n\n\n移除远程仓库名:\n\n$ git remote remove origin\n\n\n将本地仓库推送到远程仓库:\n\n$ git push -u origin master\n\ngit push 是推送到远程仓库命令，-u 是记录当前地址，下次直接输入git push 命令即可；\n\n拉取远程最新仓库:\n\n$ git pull #origin master\n\norigin master 可以不用写进去，所以这里我加了#，因为在之前默认使用-u 选项，所以git会自动识别我们之前默认的仓库名以及分支。\n\n将远程仓库克隆到本地:\n\n$ git clone git@github.com:Poluk2001/testgit.git(仓库地址)\n\n\n九：团队协作与冲突\n添加协作者的Github账户:\n 用户可以有拉取和克隆远程仓库的权限，但是推送权限只有仓库创建者所拥有，我们需要在远程仓库的setting中添加合作者：\n\n点击左侧Collaboratos\n点击Add people\n搜索需要添加合作的Github用户\n将生成的Pending Invite发送给需要的协作的用户，对方进行点击即可，即可完成合作邀请操作\n\n\n\n\n\n合并冲突:\n\n在与团队协作当中我们会时常遇到合并冲突，我们需要与另一个人进行沟通，进行手动合并\n\n在每次写代码之前，我们都要使用git pull命令来拉取仓库最新地址，保证我们本地仓库代码与远程仓库代码一致。\n\n\n将本地仓库的分支推送到远程仓库:\n\n$ git push origin 本地分支名:远程分支名\n\n\n将远程仓库分支拉取到本地仓库:\n\n$ git pull origin 远程分支名\n\n\n删除远程仓库的分支:\n\n$ git push origin :远程分支名\n\n十：跨团队协作\n\n","categories":["Note"],"tags":["Git","Github"]},{"title":"二叉树的刷题笔记","url":"/2023/05/share-BinaryTree.html","content":"最近在代码随想录上学习各种算法并做了一些记录\n\n二叉树的种类在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。\n满二叉树定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。 也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。\n如图：\n\n完全二叉树定义：完全二叉树是由满二叉树而引出来的，对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。\n如图：\n\n二叉搜索树定义：二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：\n\n若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n任意节点的左、右子树也分别为二叉查找树；\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(logn) 。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。\n如图：\n\n平衡二叉搜索树定义：平衡二叉搜索树（英语：Balanced Binary Search Tree）是一种结构平衡的二叉搜索树，它是一种每个节点的左右两子树高度差都不超过1的二叉树。它能在 O(logn) 内完成插入、查找和删除操作，最早被发明的平衡二叉搜索树为AVL树\n常见的平衡二叉搜索树有：\n\nAVL树\n红黑树\n\n如图：\n\n最后一棵树左子树高度为2，右子树高度为0，高度差的绝对值大于1了\n二叉树的存储方式二叉树可以链式存储，也可以顺序存储。\n那么链式存储方式就用指针， 顺序存储的方式就是用数组。\n顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。\n链式存储如图：\n\n顺序存储如图：\n\n如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n二叉树的遍历方式二叉树主要有两种遍历方式：\n\n深度优先遍历：先往深走，遇到叶子节点再往回走。\n\n前序遍历（递归法，迭代法）\n中序遍历（递归法，迭代法）\n后序遍历（递归法，迭代法）\n\n\n广度优先遍历：一层一层的去遍历。\n\n层次遍历（迭代法）\n\n\n\n这两种遍历是图论中最基本的两种遍历方式\n\n做二叉树相关题目时，我们经常使用递归方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。\n栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。\n而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。\n二叉树的定义public class TreeNode &#123;    int val;  \tTreeNode left;  \tTreeNode right;  \tTreeNode() &#123;&#125;  \tTreeNode(int val) &#123; this.val = val; &#125;  \tTreeNode(int val, TreeNode left, TreeNode right) &#123;    \t\tthis.val = val;    \t\tthis.left = left;    \t\tthis.right = right;  \t&#125;&#125;\n\n二叉树的深度优先遍历递归法对应LeetCode的题目：\n\n144.二叉树的前序遍历\n145.二叉树的后序遍历\n94.二叉树的中序遍历\n\n如果对递归不清楚的可以先去看一段视频了解一下：递归函数\n写递归的三要素：\n\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n\n以前序遍历为例：\n\n确定递归函数的参数和返回值，因为要打印出前序遍历节点的数值，所以参数里需要传入List来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：\n\npublic void preorder(TreeNode root, List&lt;Integer&gt; result)\n\n\n确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：\n\nif(root == null) &#123;return;&#125;\n\n\n确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：\n\nresult.add(root.val);preorder(root.left, result);preorder(root.right, result);\n\nTips：前中序遍历需将result.add(root.val)写到正确的位置\n前序遍历// 前序遍历·递归·LC144_二叉树的前序遍历class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();        preorder(root, result);        return result;    &#125;    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;        if (root == null) &#123;            return;        &#125;        result.add(root.val);        preorder(root.left, result);        preorder(root.right, result);    &#125;&#125;\n\n中序遍历// 中序遍历·递归·LC94_二叉树的中序遍历class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        inorder(root, res);        return res;    &#125;    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;        if (root == null) &#123;            return;        &#125;        inorder(root.left, list);        list.add(root.val);             // 注意这一句        inorder(root.right, list);    &#125;&#125;\n\n后序遍历// 后序遍历·递归·LC145_二叉树的后序遍历class Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        postorder(root, res);        return res;    &#125;    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;        if (root == null) &#123;            return;        &#125;        postorder(root.left, list);        postorder(root.right, list);        list.add(root.val);             // 注意这一句    &#125;&#125;\n\n\n迭代法对应LeetCode的题目：\n\n144.二叉树的前序遍历\n145.二叉树的后序遍历\n94.二叉树的中序遍历\n\n递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n前序遍历前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子，这样出栈的时候才是中左右的顺序。\n动画示意如下：\n代码如下：\nclass Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\t     //建List用来存放栈弹出的结果        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();           if(root == null) return result;        //建栈        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();          //将根节点root入栈        stack.push(root);                               while(!stack.isEmpty())&#123;       \t\t     //将出栈的值用node记录下来，并保存到result中                    TreeNode node = stack.pop();                   result.add(node.val);                     //判断被记录的node右子树值是否为空,将此节点的右子树的值入栈              if(node.right != null) stack.push(node.right);                     //同右子树逻辑一样            if(node.left != null) stack.push(node.left);        &#125;        return result;                            &#125;&#125;\n\n中序遍历为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：\n\n处理：将元素放进result数组中\n访问：遍历节点\n\n分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。\n动画示意如下：\n\nclass Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if (root == null) return result;        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode cur = root;        while (cur != null || !stack.isEmpty())&#123;\t\t    //用来访问最底层           if (cur != null)&#123;       \t        //将访问的节点放入栈中               stack.push(cur);                   cur = cur.left;      //左           &#125;else&#123;\t           //从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）               cur = stack.pop();                  result.add(cur.val);               //中               cur = cur.right;                      //右           &#125;        &#125;        return result;    &#125;&#125;\n\n后序遍历后序遍历与前序遍历的关系：\n\n前序遍历：中左右\n后序遍历：左右中\n\n如果从前序遍历得到后序遍历，首先调换前序遍历的左，右的位置，得到中，右，左，然后再翻转，得到左，右，中。\nclass Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\t     //建List用来存放栈弹出的结果        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();           if(root == null)&#123;            return result;        &#125;\t     //建栈        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();           //将根节点root入栈        stack.push(root);          while(!stack.isEmpty())&#123;             \t         //将出栈的值用node记录下来，并保存到result中              TreeNode node = stack.pop();                   result.add(node.val);            //注意先左，后右                           if(node.left != null) stack.push(node.left);            if(node.right != null) stack.push(node.right);        &#125;        //处理完后,结果集中的结果是中右左，对结果进行翻转后得到左右中        Collections.reverse(result);                    return result;                             &#125;&#125;\n\n\n二叉树的广度优先遍历二叉树的层序遍历接下来我们再来介绍二叉树的另一种遍历方式：层序遍历。\n102.二叉树的层序遍历力扣题目链接\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。\n思路：\n需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。\n而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。\n动画示意如下：\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;        //用一个二维数组来接受最终结果        List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();          //创建一个队列用来存放二叉树节点        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();            //判断是否为空        if(root == null) return resList;          //将根节点入队        que.offer(root);                                               while(!que.isEmpty())&#123;             //创建数组来存放出队的值            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;();              //记录队列的大小            int len = que.size();                 //控制队列的大小从而来控制出队的数，达到同一层的数正确的记录到一个数组中                          while(len &gt; 0)&#123;                                                     TreeNode tmpNode = que.poll();                itemList.add(tmpNode.val);                if(tmpNode.left != null) que.offer(tmpNode.left);                if(tmpNode.right != null) que.offer(tmpNode.right);                //每出队一个值，队列大小-1，                len--;                                                      &#125;            resList.add(itemList);        &#125;        return resList;    &#125;&#125;\n\n107.二叉树的层次遍历 II力扣题目链接\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n思路：\n相对于102.二叉树的层序遍历，就是最后把result数组反转一下就可以了。\nclass Solution &#123;     public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;\t    // 利用链表可以进行 O(1) 头部插入, 这样最后答案不需要再反转        LinkedList&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();                  if(root != null) que.offer(root);                                    while(!que.isEmpty())&#123;            List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;();              int len = que.size();                                           for(int i = 0; i &lt; len; i++)&#123;                TreeNode node =que.poll();                temp.add(node.val);                if(node.left != null) que.offer(node.left);                if(node.right != null) que.offer(node.right);            &#125;            ans.addFirst(temp);     //将新遍历的结果插入到链表头部        &#125;        return ans;    &#125;&#125;\n\n199.二叉树的右视图力扣题目链接\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n思路：\n层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。\nclass Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();        if(root == null) return list;        que.offer(root);        while(!que.isEmpty())&#123;            int levelSize = que.size();            for(int i = 0; i &lt; levelSize; i++)&#123;                TreeNode pollNode = que.poll();                //对栈的循环只将每层中的最后一个元素加入结果集就行，实在不理解可以画一个二叉树模拟一遍                if(i == levelSize - 1) list.add(pollNode.val);                if(pollNode.left != null) que.offer(pollNode.left);                if(pollNode.right != null) que.offer(pollNode.right);            &#125;        &#125;        return list;    &#125;&#125;\n\n637.二叉树的层平均值力扣题目链接\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n思路:\n本题就是层序遍历的时候把一层求个总和在取一个均值。\nclass Solution &#123;    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;        List&lt;Double&gt; list = new ArrayList&lt;Double&gt;();        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();        if(root == null) return list;        que.offer(root);        while(!que.isEmpty())&#123;            int levelSize = que.size();            //定义一个double类型的变量存放每层的平均值            double levelSum = 0.0;            for(int i = 0; i &lt; levelSize; i++)&#123;                TreeNode pollNode = que.poll();                //将弹出队列的元素加到变量中                levelSum += pollNode.val;                if(pollNode.left != null)  que.offer(pollNode.left);                if(pollNode.right != null) que.offer(pollNode.right);            &#125;            list.add(levelSum / levelSize);        &#125;        return list;    &#125;&#125;\n\n429.N叉树的层序遍历力扣题目链接\n给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。\n思路:\n这道题依旧是模板题，只不过一个节点有多个孩子了\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        Queue&lt;Node&gt; que = new LinkedList&lt;&gt;();        if(root == null) return ans;        que.offer(root);        while(!que.isEmpty())&#123;            int levelSize = que.size();            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();            for(int i = 0; i &lt; levelSize; i++)&#123;                Node pollNode = que.poll();                //将从队列弹出的孩子节点依次入队                for(Node node : pollNode.children) que.offer(node);                list.add(pollNode.val);            &#125;            ans.add(list);        &#125;        return ans;    &#125;&#125;\n\n515.在每个树行中找最大值力扣题目链接\n您需要在二叉树的每一行中找到最大的值。\n思路：\n层序遍历，取每一层的最大值\nclass Solution &#123;    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();        if(root == null) return ans;        que.offer(root);        while(!que.isEmpty())&#123;            int levelSize = que.size();            int levelMax = Integer.MIN_VALUE;            for(int i = 0; i &lt; levelSize; i++)&#123;                TreeNode pollNode = que.poll();                //利用max函数判断levelMax的值和出队的值谁大                levelMax = Math.max(levelMax,pollNode.val);                if(pollNode.left != null) que.offer(pollNode.left);                if(pollNode.right != null) que.offer(pollNode.right);            &#125;            ans.add(levelMax);        &#125;        return ans;    &#125;&#125;\n\n116.填充每个节点的下一个右侧节点指针力扣题目链接\n给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n思路：\n本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了\n迭代：\nclass Solution &#123;    public Node connect(Node root) &#123;        if(root == null) return root;        Deque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while(!queue.isEmpty())&#123;            int n = queue.size();            for(int i = 0; i &lt; n; i++)&#123;                Node node = queue.pop();                 if(i != n-1) node.next = queue.peek();                if(node.left != null) queue.offer(node.left);                if(node.right != null) queue.offer(node.right);        &#125;        return root;    &#125;&#125;\n\n递归：\nclass Solution &#123;    public Node connect(Node root) &#123;        if(root == null) return null;        DFS(root);        return root;    &#125;    public void DFS(Node root)&#123;        //递归退出条件，需要用到父节点来操作.next指向右邻居，所以最后一次递归执行是当root到叶子结点的上一层对叶子结点进行操作        if(root.left == null || root.right == null)&#123;            return;        &#125;        //root的左孩子肯定有右邻居        root.left.next = root.right;        //如果父亲节点有右邻居，那么父节点root的右孩子一定也有右邻居        if(root.next != null)&#123;            root.right.next = root.next.left;        &#125;        //前序遍历        DFS(root.left);        DFS(root.right);    &#125;&#125;\n\n117.填充每个节点的下一个右侧节点指针II力扣题目链接\n思路：\n这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道\nclass Solution &#123;    public Node connect(Node root) &#123;        if(root == null) return root;        Deque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while(!queue.isEmpty())&#123;            int n = queue.size();            for(int i = 0; i &lt; n; i++)&#123;                Node node = queue.pop();                 if(i != n-1) node.next = queue.peek();                if(node.left != null) queue.offer(node.left);                if(node.right != null) queue.offer(node.right);        &#125;        return root;    &#125;&#125;\n\n104.二叉树的最大深度力扣题目链接\n给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n思路：\n使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。\n在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：\n\n递归：\nclass Solution &#123;    public int maxDepth(TreeNode root) &#123;        if(root == null)&#123;            return 0;        &#125;        //计算左子树深度        int leftHight = maxDepth(root.left);        //计算右子树深度        int rightHight = maxDepth(root.right);        //从左子树和右子树深度中选一个最大的值和当前节点+1，并且返回maxHight        return Math.max(leftHight,rightHight) + 1;    &#125;&#125;\n\n迭代：\nclass Solution &#123;    public int maxDepth(TreeNode root) &#123;        if(root == null) return 0;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        int depth = 0;        while(!queue.isEmpty())&#123;            int size = queue.size();            for(int i = 0; i &lt; size; i++)&#123;                TreeNode pollNode = queue.poll();                if(pollNode.left != null) queue.offer(pollNode.left);                if(pollNode.right != null) queue.offer(pollNode.right);            &#125;            depth++;        &#125;        return depth;    &#125;&#125;\n\n111.二叉树的最小深度力扣题目链接\n相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。\n需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点\nclass Solution &#123;    public int minDepth(TreeNode root) &#123;        if(root == null) return 0;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        int depth = 0;        while(!queue.isEmpty())&#123;            int size = queue.size();            depth++;            for(int i = 0; i &lt; size; i++)&#123;                TreeNode pollNode = queue.poll();                //如果当前节点的左右孩子都为空，直接返回最小深度                if(pollNode.left == null &amp;&amp; pollNode.right == null) return depth;                if(pollNode.left != null) queue.offer(pollNode.left);                if(pollNode.right != null) queue.offer(pollNode.right);            &#125;        &#125;        return depth;    &#125;&#125;\n","categories":["Note"],"tags":["LeetCode","算法"]},{"title":"分享一点自己在 B 站收藏的“比较有质量”的课程","url":"/2023/04/share-bilibili.html","content":"随便说一点   我自己在日常会整理、收藏一些比较有质量的课程，特别想分享在这里，分享给有需要的人！。\n   我分享的列表课程并不能代替那些质量公开课。 每个人水平不同，而且我分享的列表中也有一些985大学在校生讲的而且讲的非常不错，我只是分享出来，帮助有需要和有需求的人。\n   \n\n   国内的公开课数量和质量也在大大增加，比如南京大学的几位老师近几年都在平台上分享自己的课程实录，甚至上课的时候同时开直播，与南大学子一起上课。\n   本来也想整理一些有质量的Up主的，但是我的账号关注数有一点小多，暂时就不整理分享了。如果各位大佬有推荐的UP,以及质量课程可以发在评论区一起交流。收藏不等于学会，同时也祝我们国内更好的课程越来越多。\n   第一次在这里做分享，本人比较菜，有些课程分类可能不正确，但是尽力了，希望各位轻喷！\n操作系统&#x2F;计算机组成\n操作系统实现\n操作系统速成-2022秋冬朋辈辅学录播\nCSAPP-深入理解计算机系统-讲解\n“一生一芯”\nMIT6.828&#x2F;6.S081操作系统课程教程\n从零开始自制操作系统\n2023 南京大学 “操作系统：设计与实现” (蒋炎岩)\n厦门大学-操作系统原理（2022春）\n现代操作系统：原理与实现（上海交通大学）\n【操作系统原理】清华大学陈渝教授\n深入理解计算机系统—个人讲解\n深入理解计算机系统-CSAPP重点导读\nDr.Dng陪跑CSAPP: bigONE《深入理解计算机系统》\nCS162操作系统-精译(更新中)\n台湾清华大学 - 操作系统 Operating Systems - 黄能富教授\n\n编译相关&#x2F;软件分析\n南京大学《软件分析》课程2020\n手写一个 RISC-V 编译器！初学者友好的实战课程\n南京大学软件学院编译原理课程\n\n数据结构&#x2F;算法相关\n东北大学：2021～2022春季学期算法设计与分析\n南京大学《2023算法设计与分析》- 黄宇\n南京大学《2023算法设计与分析》- 徐经纬\n数据结构与算法基础（青岛大学-王卓）\n跟懒猫老师快乐学数据结构\n\n计算机网络\n计算机网络-通熟易懂讲解每个知识要点\n中科大郑烇、杨坚全套-计算机网络（自顶向下方法)\n计算机网络微课堂\n\n程序语言&#x2F;编程语言\n计算机程序的构造与解释（SICP, Python版）\n计算机语言 x86汇编语言：从实模式到保护模式（操作系统引导课）\n程序语言理论与实现\n【CS公开课】计算机程序的构造和解释（SICP）\n精译-UC Berkeley 公开课-CS61A【计算机程序的构造和解释】 (Spring 2021)\n\n软件工程\n南京大学-2023软件工程与计算 I\n\n数据库\n数据库系统（DBMS）\nCMU15-445-精译(更新中)\n\n并行程序设计\n并行程序设计 谭光明\n高性能并行编程与优化\n新竹清华大学：并行计算与并行编程课程\n\n工具\n浙江大学：「实用技能拾遗」2023 春夏朋辈辅学\nObsidian公开课\n\n不会分类的or列表太少不至于分类的\n硬件茶谈：硬核科普\n精读c++primer\n计算机图形学游戏方向-2023年春季第2次迭代-谭剑\nLinux 文件系统九讲-陈硕\nDDIA 读书逐章分享\n机器学习-白板推导系列\n陈明-南京大学23春-面向对象编程基础\n每个程序员都应该知道的内存知识 (带你走读Ulrich Drepper的经典论文)\nLinux 操作系统 核心設計 ||完结\n\n","categories":["Note"],"tags":["分享"]},{"title":"简易的生存手册","url":"/2023/09/SelfExperience.html","content":"这份简易手册的简易说的更多的是在成为一个合格的程序员职业生涯中，我们现阶段(专科)能掌握一部分的技术就行，这也是有些学校假当然有能力学的更多是好事。其实对计算机科学(Computer Science)而言，这门学科并不简易。我认为在这个环境中的教学内容的量和难易程度距离计算机科学的世界还是很远。\n\n\n写这份手册初衷是因为在我大一刚开始接触程序开发也是有很多困惑的，对很多东西没有清楚的认识，也没有人指点，很容易迷茫。自学这条路难免走不少弯路，就目前来说还算走的相对正确一点，一部分技术和视野还是获得了的。想通过这篇文章来分享一下自己在这两年学习程序开发的心得体会和一点经验，为海院信息工程学院的软件开发相关的新同学提供一些帮助。\n也是想了很久考虑要不要写，主要是因为个人目知识的学习还在继续，并且考虑自己的能力是否能给出相对于好的建议，一定做好概念的解释和严谨性，写下来需要很长时间\n本篇个人心得和经验，具有较强主观性陈述，如有疑问和错误，欢迎通过评论或邮件沟通。\n写在前面讲点自己在学校两年间的心路历程\n大一：2021.10至2022.06在高考完之后，专业的录取结果是软件开发专业的，当时也开了个线上班会带所有软件开发的学生浏览了一遍我校教学计划，编程语言(Programming Language) 用的就是用Java语言，于是就抱起了提前一点学Java的想法了。在Bilibili一搜Java课程一大把，满眼看过去大部分都是机构课程，其实当时觉得机构课程都非常非常棒，尤其像黑马程序员，尚硅谷至今也是目前公开课程最多，质量优秀的两大机构。不过这个结论是我后来才产生的，在起初充斥着各大机构的Java课程里，我根本就无法判断搜索结果里内容的质量高低，于是我就开始在百度搜寻各种建议，听哪一家的比较好？但是大家都推荐黑马程序员，集数真的很多很多，他们把知识点的讲解细分成很多集，但是好在每集其实并不是很长，于是我就开始看课并且跟着写代码。\n其实当时Java被很多机构宣传的很多，也进一步劝了很多人进入了Java的坑。当时2021年计算机的行情还算可观，我当时的想法就是学好Java这门语言和流行的开发框架就一定可以找个好工作了。\n但后面看到不及集数的1&#x2F;3，我就开始听的有点懵的状态了，后面就直接又在众多搜索结果了换了一套教程。因为在初中接触过一段时间的Java学习，学到数组差不多就开学了。后面就在学校上线下课，但是那会自己学的进度已经赶在了老师教学进度之前，就继续赶Java基础语法的进度了。\n在大一第一学期的时候，当时的Java任课老师蒋玉婷老师在课堂上讲了一下蓝桥杯的比赛，后面因为比赛需要训练时间和个人规划的冲突问题犹豫了一段时间，最终我还是联系了老师成为预选，在2022年的3月春季开学老师确定好了人选，最终报名了比赛。最最最重要的是学校为每位参赛选手提供了报名费以及蓝桥杯VIP题库的名额。在4月份比赛之前都是在蓝桥杯官网做练习题，其实当时我已经意识到参加算法比赛是要有一定的编程语法基础，数据结构基础，以及基础算法基础的，当时没有这些课程的教学，我只有简单的Java语法基础，由于时间有限，我只能理解题意的思维去刷题或看题解刷题。\n最终水了一个省二等奖的名次，同参加的校友还有一位获得了省一等奖和一位进入了国赛的选手。不过也是一次体验，也算是一份小小的荣誉，很大程度上的增加了我对技术学习的信心和热情，也感谢蒋老师捞我报比赛。大一除了Java基础语法，也学了基础的Web设计，包括HTML，JavaScript，CSS，其实我更喜欢前端，因为我可以通过编码设计出自己喜欢的样式，并且也享受其中。大一第二学期结课之前完成了最后一个大作业（如图）。\n主页部分：\n\n博客部分：\n\n在整个大一有部分是课堂听讲，一部分情况下自学的较多，大一除了Web，Java基础以及MySQL，还有其它比较实用的操作课程比如Linux。\n其实大一第二学期中旬才把Java语法学完，这个进度是有点慢的，是因为当时按照那个课程一直看到进阶的知识，后来才意识到的。其实那部分知识很难，当时也不怎么用的到，进阶的几个技术点都可以单独拎出来学习的，甚至到现在也有点遗忘了。\n大二：2022.08至2023.07大二实行专业分流，软件技术分成前端(front-end)和后端(back-end)，我喜欢后端所以选择了后端(其实那时候我对后端的概念比较模糊)，在看过众多建议和了解一些。在大一的时候很多人强调了计算机基础的重要性。大一结束完，我看了南京大学-袁春风《计算机系统基础》，这门课讲的更多的是计算机组成，因为看的也是有点囫囵吞枣，但是对计算机运作的原理算是有了一个简单的认识。并且在暑假期间开始折腾了一个博客，就是现在的博客，虽然花了大量的时间去查阅搭建和使用，但是最终能学到的不止于这些，在今年9月开学我又重新装饰了一下博客，就如你现在看到的样子。\n大二开始后端框架的教学，其实我在课堂上没有听懂，后面是课下花了时间又去自己学，课堂上听不懂的结果无疑是会占用大多数课下的时间，导致课上时间是没有价值的。接着的其余时间学习了中科大-郑烇《计算机网路：自顶向下》。计算机基础是枯燥的，没有编码练习又很难真正的理解知识点，导致了我在大二第二学期二刷这门课程，这一遍对计算机网络知识的框架又进一步深入和理解，但是对于这次的学习不足的还是缺少实验的实践对知识进一步理解。网上有实践项目但是前置知识缺少无法继续进行，计划放在后面补充完前置知识再继续完成实践项目。\n第二学期依旧是框架技术的学习，学习的分布也如同第一学期，第二学期也是心情和技术提升波动最大的一学期。第一是：随着互联网寒冬的来临，众多企业开始裁员，我质疑自己是否能坚持这条路，面对未来还没就业就已经先失业的环境我很焦虑。第二是：我是一个倾向于喜欢计划再行事的人，不规划好一些东西，我在任何时候总会去想着这些事情的顺序，担心忘记。所以第二学期也因为自己没预先充分了解课程前置知识，规划了几门课程的学习目标，导致学的过程很痛苦，过度认为是因为自己足够笨拙。然后和朋友沟通，谈心，了解原因后，于是重新规划自己的路线，最终这些不好的情绪也随之散去，也感谢我的朋友们。在第二学期的5月中旬把数据结构学完，后面就在刷题了。持续了一个半个月左右，然后临近放假也没再刷了。刷题也很痛苦的，刷到mid的时候，看题解也理解不了代码逻辑的话会极度痛苦。\n大二结束的假期，也就是这个暑假，又重新学习了计算机组成、操作系统(未完) ，跟的课程是之前比较畏惧的CMU 15-213 CSAPP 深入理解计算机系统，但是没有做Lab以及只听了几张重要的章节，但计划在后面抽时间尝试做。不过在大二的寒假只读了这门课程配套的书籍 《Computer Systems: A Programmer’s Perspective》 简称：CSAPP，中文名：《深入理解计算机系统》 但是配套的Lab做完Lab1就已经到达能力的极限并且还差一点做完。\n大二一直都在偏向于计算机基础的学习，不过在Spring Boot学完之后自己跟了一个简单的增删改查(CRUD)的项目，虽然项目不是很难，但是跟着做完之后会对Spring Boot开发有一个进一步的理解和实战技能的提升，不过这些还远远不够，增加开发经验需要阅读更多的开源项目和使用Spring Boot做项目\n虽然在正确的道路上拐来拐去，自学很那避免走写弯路和时间的浪费，但总体来说两年的时间颇有收获，比如技术的掌握，视野增加，信息的搜索和辨别能力。其实除了文章中提到的的技术和知识，还有一部分学习和折腾过程中也学到了很多，单独去学一门技术其实能学到的仅仅是你目标，很多技术大多是都在折腾和搜寻问题的过程中学习到。\n路线先阅读这里：\n\n课程推荐里的大部分是我看过的，每个技术点只需从中选择一门合适的观看就够了，还可以选择除本文推荐外的课程，比如黑马和尚硅谷的课程，他们的所有技术都有公开课程。\n\n路线方面有两个大致的路线可以参考，选择路线一的直接完全可以按照黑马和尚硅谷的路线来就行，如果你觉得黑马和尚硅谷路线里自带的课程不适合你，那么你可以在我我的课程推荐目录里选择一门就好。选择路线二的你就按照我给你的顺序去看。不过由于有的视频在Bilibili可能会因为未知原因被下架，所以目录里的链接可能会有失效的情况，如有失效，请及时评论进行反馈。\n\n\nPS:关于路线和课程推荐，不做任何绝对的强制推荐，可供大致参考。如果你在某个时间过后意识到之前阅读的这篇文章对你有益或者适合，那么你可以尝试。\n路线一：仅仅学习流行技术+项目实践如果你只是想掌握并且又希望学的内容比学校多，可以按照 黑马程序员或者尚硅谷的技术路线学习，在之前提到过，这两大机构的课程质量是优秀的，我也听过这两个机构的部分课程，路线里也有给推荐项目实战教程。\n但要说的一点是，路线的技术点是顺序是这样的，但是课程并不用一定听他们的，如果你听不明白学习路线中某一门课，你完全可以换一套教程，比如Java基础你觉得学习路线里自带的课程并不适用于你，你可以寻找一门更适合自己的Java基础课程。但找到一门合适的课你需要不断的听，后面可能又听不懂，然后再换…就这样反复循环，这无疑是浪费时间的。而且大部分机构的课程是非常冗余和多集数的，我在后面的具体技术课程推荐目录里会分享相对不错的课程，但不保证一定适合你，有时候开始听不懂的时候，不能忽略的一点是考虑一下是不是自己的问题。不过缺少了计算机基础的支撑，你在面对很多问题可能很棘手，并且你的技术成长可能很快遇到瓶颈，不建议只走这条流行技术路线。\n路线二：计算机基础+流行技术+项目实战其实这一路线也就是在上面两大机构路线中并行学习计算机基础知识\n顺序：Java SE基础 以及 C语言基础 (因为后面学计算机基础几乎所有的课程需要C语言基础才能看懂课程案例代码) → Javaweb技术 \n课程推荐\n推荐分为计算机基础部分和主流技术部分\n\n计算机基础部分计算机组成原理\n南京大学-袁春风《计算机系统基础》\n 此课分为五个大部分，听完三这一部分即可，具体点击这里查看课程列表\n\n\n操作系统\n哈工大-李治军《操作系统》\n\n数据结构\n青岛大学-王卓《数据结构与算法基础》\n\n计算机网络\n中科大-郑烇《计算机网路：自顶向下》\n\n主流技术部分Java基础语法\n语法基础一定要学牢固。\n\n\n马士兵教育-2021版java就业班全套视频讲解 \n 这门课是我自己当初看的，他也包括了框架开发技术，还有工具的技术，所以只需要关注P1-P171是基础入门，P172-P351是进阶，这个进阶部分也是前面提到的导致我学语法进度比较慢的原因，进阶部分可根据自己能力和时间多少来选择听取，不过最终也是要补这部分知识的，这部分进阶技术不受限于编程语言，也就是说任何想成为一名合格的Coder都需要学习并掌握这部分技术，只是实现这些技术的编程语言可以是任何\n\n楠哥2021最新Java零基础实战全套教程，从入门到精通\n 这位讲师我在大一结束的暑假里学JavaWeb发现的，我大致看了一下这门课程只有60h+的时长，我听过这位讲师的其他两门课程都觉得非常清晰容易理解。\n\n\n数据库\nMySQL数据库入门到精通\n\nJavaWeb\n这个一定跟着课程操作一遍，不管哪个课程要跟一遍！这门课程就是很早之前用通过各种技术以及Java构建Web应用的操作，搞懂Servlet，JDBC，还有整个JavaWeb程序的大概运行逻辑和顺序。\n\n\nJava Web从入门到实战\n Java web 是指由Java语言开发出来可以在万维网上访问浏览的程序。\n Web通过一系列的通信实现与Java的交互，Java是你的后台，进行逻辑处理，中间层进行数据的交互，Web显示给用户来看。就好像你买东西付款，钱是你能看到的–钱：Web，收钱和找零通过手来执行–手：中间层的作用，大脑来算出应该找零多少–大脑：Java后台。\n 这门是在大一结束暑假提前预习JavaWeb找到的，讲的比较清晰，是我目前见到的比较小众和干净的Java Web课程了。\n\n\nSpring Mvc以及Spring\n先学Sring MVC，再学Sping。关于Spring和Java EE的区别，可参考这篇文章，如有不懂，可自行搜索查阅更多相关资料。\n\n\n2022年厦门大学JavaEE平台技术课程\n 这门是在去年10月多份Bilibili首页刷到的课程，当时试听了一下感觉讲的非常清晰透彻，包括Java EE、Spring以及Spring Boot技术的历史发展。不过我听了前几节课发现比较偏向于技术的概念的讲解，没有太多上手的实际操作。可以通过这门课快速了解基于Spring框架开发的流行技术，实操之前看可以当做了解，实操之后可以再次用作于知识的巩固，毕竟课时不长。\n\n动力节点SpringMVC框架实战教程\n 在计算机科学中，MVC是一种软件设计模式，这种模式将应用代码组织成三个相互交织的部分——模型、视图和控制器。\n 模型是与数据库交互的逻辑；视图是用户接口和交互，控制器是是视图和数据库之间的中介。\n 大多数情况下，视图不直接和模型交互——这个功能由控制器执行。\n\n跟老杜从零学spring入门到高级\n\n\nSpring Boot\nSpring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。更多内容请参考这里\n\n\n黑马程序员SpringBoot2全套视频教程\n\n黑马程序员SSM框架教程\n SSM是：Spring&#x2F;Spring Boot + SpringMVC + Mybatis&#x2F;Mybatis Plus 三项技术，每一个技术的英文首字母组合简称SSM。\n 推荐直接看这门，因为时长短，以上那些课程的内容都是针对每一项技术的细致讲解。这套SSM教程是直接对三大技术整合的教程，也包括各个技术知识点的讲解，只不过没有单独技术讲解的细致。\n\n\n中间件及工具\n4小时Redis极简入门\n\n黑马程序员Maven全套教程\n\n一小时Git教程\n\n黑马程序员最新MybatisPlus全套视频教程\n\nMyBatis零基础入门教程\n MyBatisPlus是MyBatis的加强版本，初学时掌握MyBatis即可，但后续有时间可以再学一下MyBatisPlus，技多不压身，根据需求选择用MyBatis还是Plus。\n\n\n项目实战\n黑马程序员Java项目实战《瑞吉外卖》\n 这门大多数人都在推荐，而且很多已经把他改个名字写在了简历上\n\n2023全网最简单但实用的SpringBoot+Vue前后端分离项目实战（第一季）\n 非常非常推荐这门实战课，简单易懂，但是前置知识是要学完之前的框架以及部分工具的技术。这门课程目前有两季，第二季你们自行去UP主的主页里寻找。在大二的第二学期中旬左右，我跟了这个项目，跟完之后我对Spring Boot的开发又有了更深的理解，包括整个后端开发流程以及前后端对接的过程。\n\n若依\n建议先做完2项目之后再来看这个，这个项目是一个优秀的开源项目，大家选择前后端分离的版本即可。官方文档其实我也很难看懂，不过大家可以看一个博主讲的视频：若依前后端分离版，通俗易懂，快速上手，这个视频讲的仅仅只是一部分，更深的技术探寻还需要在你掌握更多知识或者有能力的时候再去研究项目源码。\n\n\n","categories":["Note"],"tags":["总结"]},{"title":"记录一下最近的思绪","url":"/2023/05/share-myideas.html","content":"最近思绪很多所以想把这些记录一下。\n这学期开学来时常会有焦虑，心情一直在焦虑和平静中起伏。本来这学期是计划找实习，这样能在工业界里学到更多的相关知识，总比待在学习里好。但是在BOSS上，里面大多都是投了无数多的简历并且连个面试的机会都没有的帖子，这只会让我更焦躁。看了招聘条件后总觉得自己还是差点东西才能胜任这份实习，尽管对实习生其实并不需要多高的技能水平。鉴于这样的情况，我暂时还是打消了找实习的念头，打算花更多的时间再提升一下技能水平。\n\n\n最近因为学习算法中遇到了一些问题，又开始有些焦躁。在过去两年中每次在接触并且学习新东西的时候会产生各种的迷茫，也许对我来说没办法，自学总是不弯弯绕绕很难走到正确的路。很遗憾大一的时候自己的认知和视野没有照到相对正确的路上，导致了一些时间花在学习变化很快的主流技术上面，没有从计算机基础开始。\n其实我喜欢计算机相关，也愿意从事这份工作，但并不想做一个简单的CRUD开发者，想在一个喜欢的领域里贡献自己那份仅有的价值。也许期望太高了？这只不过是个最终理想罢了。我总是为项目里需要用到的技能而去学某些东西，但是学完之后从未觉得它们被我拥有过，只是单纯的拿它们用来服务所需的项目里，从来没想过自己能用它们做一些自己觉得有意思的事情，这是我意识到自己所缺的那部分。\n一直觉得焦虑是可以有的，但是不能长期焦虑影响到自己的生活。与其不停的让自己处于焦虑中，倒不如提升自己，多做事情，让自己在未来的日子里能施展能力的概率更大一点。\n在经济下行的环境中，个人的努力显得微不足道，我也做好了“尽管学再多的技术也找不到工作”的心里准备。也庆幸自己在不好的环境中还可以通过互联网认识到了诸多的优秀开发者，同样也可以看到世界级名校的公开课，从优秀的开发者中学到了很多并且得到了受益的建议与鼓励。他们如此谦逊并且愿意分享自己的经验给陌生人，也许这个群体受益于开源的思想吧。\n在大学两年最能影响到我的是Ray-Eldath，在3月底最焦虑和迷茫的日子里我写信给他寻求职业发展的建议，这也是我第一次以长文的形式写信给别人，虽然文笔并不是很好，但是我尽量的表达清楚。而在他的回信中我感到他的文字充满力量并不禁感叹文笔如此的好，翻过他的博客我知道这一定离不开他本人拥有浓厚的文学知识。\n在回信中让重新对以后充满期望的一句话就是：“‘人灵魂的欲望是其命运的先知’，每当在埋头苦读中感到疲乏、有退缩之意时，我总在心中默念这个句子，因为坚定而不屈的灵魂值得美好又光明的未来，他们在人群中熠熠生辉。我们要为成为那样的人而努力。”\n之前还想过并且不止想过一次，在城市里工作感到真的真的疲惫的那时，那就选择一个喜欢的城市去经营一个自己喜欢的店铺(也许是苏州？)，我向往最好一点的生活也就是这样了。甚至还有个想法就是做海洋救助的公益，很难实现，但是我心里是想做，也许这也是一个终极理想吧？但这都是留给自己的“退路”。\n大学这两年我也慢慢成为了知识的虔诚信徒，也明白知识是可贵的，虽然身处环境一般但敬畏知识。还算年轻，我还有很多喜欢的东西来支撑着我期许未来，很多很多喜欢的衣服还没有穿，被称之为“不夜城”的香港和“自由乌托邦”的阿姆斯特丹还没有去，有很多热爱和喜欢的事物还没有去接触。\n想起Ray-Eldath在信中提到过一篇题为《拥抱苦差事》的文章中里引用的一句话：“如果某个魔术所需的时间、金钱或练习的次数，比你（或任何一个普通人）所愿意付出的更多，那你就会被骗到”。如果你愿意拥抱苦差事，你就可以完成不可能完成的任务，但愿我们在拥抱苦差事之后也可以被更多一点的幸运所眷顾，让我们去展示这些“魔法”。\n写下这些也是想让自己在这段文字之后让自己重新期待未来，好好享受“暂时不用考虑社会里烦恼”的日子，安静的做自己喜欢的事情。\n","categories":["Daily"],"tags":["生活","思绪"]},{"title":"加缪获颁诺贝尔文学奖致谢辞(中法)","url":"/2023/06/Albert-Camus-NobelTalk.html","content":"Sire, Madame, Altesses Royales, Mesdames, Messieurs,\n国王陛下，王后，各位殿下，女士们、先生们，\nEn recevant la distinction dont votre libre Académie a bien voulu m’honorer, ma gratitude était d’autant plus profonde que je mesurais à quel point cette récompense dépassait mes mérites personnels.\n秉承自由精神的瑞典皇家科学院将这份殊荣授予我，万分感激之余更添万般惶愧。\nTout homme et, à plus forte raison, tout artiste, désire être reconnu. Je le désire aussi. Mais il ne m’a pas été possible d’apprendre votre décision sans comparer son retentissement à ce que je suis réellement. \n再理智的人，再理智的艺术家，都渴望被认可。我也不例外。但比起自己所做的一切，这份殊荣是过于沉重了。\nComment un homme presque jeune, riche de ses seuls doutes et d’une œuvre encore en chantier, habitué à vivre dans la solitude du travail ou dans les retraites de l’amitié, n’aurait-il pas appris avec une sorte de panique un arrêt qui le portait d’un coup, seul et réduit à lui-même, au centre d’une lumière crue ? De quel cœur aussi pouvait-il recevoir cet honneur à l’heure où, en Europe, d’autres écrivains, parmi les plus grands, sont réduits au silence, et dans le temps même où sa terre natale connaît un malheur incessant ?\n一个年届不惑却依然满怀困惑的人，创作生涯正值中途，习惯远离朋友、孤独劳作，突然被拦下脚步、推至聚光灯下，四顾无援的他怎能不惊慌失措？他将藉着怎样的心情来接受这份荣耀？此时此刻，就在欧洲，有许多作家，甚至是最伟大的作家，依然默默无闻、乏人问津；此时此刻，就在我出生的地方，依然不幸接连着不幸。\nJ’ai connu ce désarroi et ce trouble intérieur. Pour retrouver la paix, il m’a fallu, en somme, me mettre en règle avec un sort trop généreux. Et, puisque je ne pouvais m’égaler à lui en m’appuyant sur mes seuls mérites, je n’ai rien trouvé d’autre pour m’aider que ce qui m’a soutenu tout au long de ma vie, et dans les circonstances les plus contraires : l’idée que je me fais de mon art et du rôle de l’écrivain. Permettez seulement que, dans un sentiment de reconnaissance et d’amitié, je vous dise, aussi simplement que je le pourrai, quelle est cette idée.\n这样的惶惑不安与内心焦灼于我并不陌生。面对命运的过度垂青，想要重归平静，唯有力求问心无愧。既然我所做的一切与此盛誉颇不相称，别无他法，只有拿一生中最险恶的逆境下支撑我的信念来应对：对艺术的信念，对作家这一角色的信念。借此机会，怀着感激和友善之情，敬请诸位允许我用最简约的方式来阐释这两种信念\nJe ne puis vivre personnellement sans mon art. Mais je n’ai jamais placé cet art au-dessus de tout. S’il m’est nécessaire au contraire, c’est qu’il ne se sépare de personne et me permet de vivre, tel que je suis, au niveau de tous. \n没有艺术，我的生命将不复存在。但我从不将这艺术至于一切之上。如果说艺术对我而言不可或缺，那是因为它决不自我孤立，在与他人同等的层面上，让我本色地活下去。\nL’art n’est pas à mes yeux une réjouissance solitaire. Il est un moyen d’émouvoir le plus grand nombre d’hommes en leur offrant une image privilégiée des souffrances et des joies communes. \n我觉得艺术不应是独自享受，而是一种方法，用它来感动最大多数的人，向他们奉献一种超乎苦痛和普通欢愉之上的形象。\nIl oblige donc l’artiste à ne pas se séparer ; il le soumet à la vérité la plus humble et la plus universelle. Et celui qui, souvent, a choisi son destin d’artiste parce qu’il se sentait différent apprend bien vite qu’il ne nourrira son art, et sa différence, qu’en avouant sa ressemblance avec tous.\n它迫使艺术家不再自我孤立，让他臣服于最卑微、最普遍的真理。通常情况下，选择献身艺术的人，都曾自视与众不同。然而他很快会发现，自己的艺术、自己的与众不同，往往就扎根在与所有人的相似中。\nL’artiste se forge dans cet aller retour perpétuel de lui aux autres, à mi-chemin de la beauté dont il ne peut se passer et de la communauté à laquelle il ne peut s’arracher. C’est pourquoi les vrais artistes ne méprisent rien ; ils s’obligent à comprendre au lieu de juger. Et s’ils ont un parti à prendre en ce monde ce ne peut être que celui d’une société où, selon le grand mot de Nietzsche, ne règnera plus le juge, mais le créateur, qu’il soit travailleur ou intellectuel.\n艺术家就是在自我与他者不断的交往中、在半途不可错过的美景中、在无法抽离的群体中慢慢锤炼自己的。因此，真正的艺术家看重一切，他们逼迫自己去理解，而不仅仅满足当个评判。在这世上，他们必须选择一个阵营，那一定是代表某一集团的立场，据尼采的伟大洞见，在这个集团中，占统治地位的不是判官，而是创造者，他们之中既有劳动者，也有知识分子。\nLe rôle de l’écrivain, du même coup, ne se sépare pas de devoirs difficiles. Par définition, il ne peut se mettre aujourd’hui au service de ceux qui font l’histoire : il est au service de ceux qui la subissent. \n再来谈谈作家的角色，同样责任重大。确切地说，今天的作家不应为制造历史的人服务，而要为承受历史的人服务。\nOu sinon, le voici seul et privé de son art. Toutes les armées de la tyrannie avec leurs millions d’hommes ne l’enlèveront pas à la solitude, même et surtout s’il consent à prendre leur pas. \n否则，他将形影相吊，远离真正的艺术。任何暴君的千百万军队都无法将一个作家从孤独中拯救出来，尤其当这个作家同他们的步调一致的时候。\nMais le silence d’un prisonnier inconnu, abandonné aux humiliations à l’autre bout du monde, suffit à retirer l’écrivain de l’exil chaque fois, du moins, qu’il parvient, au milieu des privilèges de la liberté, à ne pas oublier ce silence, et à le relayer pour le faire retentir par les moyens de l’art.\n相反，一个无名囚徒的沉默，一个被遗弃在世界另一个角落百般受辱的囚徒，就足以将作家从流放中召回，就算这个作家身处优境，只要他不忘记这种沉默，用艺术的种种方式来彰表这种沉默。\nAucun de nous n’est assez grand pour une pareille vocation. Mais dans toutes les circonstances de sa vie, obscur ou provisoirement célèbre, jeté dans les fers de la tyrannie ou libre pour un temps de s’exprimer, l’écrivain peut retrouver le sentiment d’une communauté vivante qui le justifiera, à la seule condition qu’il accepte, autant qu’il peut, les deux charges qui font la grandeur de son métier : le service de la vérité et celui de la liberté. \n我们之中没有一个人能强大到不负这一使命。但在作家漫长一生的境遇中，晦暗也好，腾达也好，在暴君的铁牢中也好，能自在发出声音时也好，只要他尽力做到为真理服务，为自由服务，他就能重新找回勃勃而富有生机的集体情感和支撑。为真理服务，为自由服务，这两条也足以体现作家职业的伟大。\nPuisque sa vocation est de réunir le plus grand nombre d’hommes possible, elle ne peut s’accommoder du mensonge et de la servitude qui, là où ils règnent, font proliférer les solitudes. Quelles que soient nos infirmités personnelles, la noblesse de notre métier s’enracinera toujours dans deux engagements difficiles à maintenir : le refus de mentir sur ce que l’on sait et la résistance à l’oppression.\n既然作家的使命是团结尽可能多的人，那就只有容忍谎言和奴性。这个世界充斥着谎言和奴性，孤独的荒草到处疯长。无论我们每个人有怎样的弱点，作家职业的高贵永远植根在两种艰难的介入中：拒绝谎言，反抗逼迫。\nPendant plus de vingt ans d’une histoire démentielle, perdu sans secours, comme tous les hommes de mon âge, dans les convulsions du temps, j’ai été soutenu ainsi : par le sentiment obscur qu’écrire était aujourd’hui un honneur, parce que cet acte obligeait, et obligeait à ne pas écrire seulement. Il m’obligeait particulièrement à porter, tel que j’étais et selon mes forces, avec tous ceux qui vivaient la même histoire, le malheur et l’espérance que nous partagions. Ces hommes, nés au début de la première guerre mondiale, qui ont eu vingt ans au moment où s’installaient à la fois le pouvoir hitlérien et les premiers procès révolutionnaires, qui furent confrontés ensuite, pour parfaire leur éducation, à la guerre d’Espagne, à la deuxième guerre mondiale, à l’univers concentrationnaire, à l’Europe de la torture et des prisons, doivent aujourd’hui élever leurs fils et leurs œuvres dans un monde menacé de destruction nucléaire. Personne, je suppose, ne peut leur demander d’être optimistes. \n二十多年荒唐的历史进程中，我茫然无助，和许多同龄人一样，在时代的剧烈动荡中，仅靠一种情感模模糊糊地支撑自己：写作的光荣。写作之所以光荣，是因为它有所承担，它承担的不仅仅是写作。它迫使我以自己的方式、凭自己的力量、和这个时代所有的人一起，承担我们共有的不幸和希望。这代人，生于一战之初；二十来岁时伴随早期的工业革命进程，又遭遇希特勒的暴政；随后，仿佛要让他们的经历更完美，发生了西班牙战争、二战、集中营惨剧，整个欧洲满目苍夷、狱祸四起；如今，他们又不得不在核毁灭的阴影下哺育子嗣、成就事业。没人能要求他们更乐观。\nEt je suis même d’avis que nous devons comprendre, sans cesser de lutter contre eux, l’erreur de ceux qui, par une surenchère de désespoir, ont revendiqué le droit au déshonneur, et se sont rués dans les nihilismes de l’époque. Mais il reste que la plupart d’entre nous, dans mon pays et en Europe, ont refusé ce nihilisme et se sont mis à la recherche d’une légitimité. Il leur a fallu se forger un art de vivre par temps de catastrophe, pour naître une seconde fois, et lutter ensuite, à visage découvert, contre l’instinct de mort à l’œuvre dans notre histoire.\n我甚至主张在与之斗争的同时，要理解他们的错误。他们只是因为过度绝望才行不智之举，对时代的虚无主义趋之若鹜。但终究我们中的大多数，不止是在我国，也在整个欧洲，都拒绝这样的虚无主义，致力于追寻合法性。我们需要锻造一种灾难时代生活的艺术，以全新的面貌获得再生，与历史生涯中死亡的本能作斗争。\nChaque génération, sans doute, se croit vouée à refaire le monde. La mienne sait pourtant qu’elle ne le refera pas. \n或许，每一代人都自负能重构这个世界。而我们这一代人却明白这是痴人说梦。\nMais sa tâche est peut-être plus grande. Elle consiste à empêcher que le monde se défasse. Héritière d’une histoire corrompue où se mêlent les révolutions déchues, les techniques devenues folles, les dieux morts et les idéologies exténuées, où de médiocres pouvoirs peuvent aujourd’hui tout détruire mais ne savent plus convaincre, où l’intelligence s’est abaissée jusqu’à se faire la servante de la haine et de l’oppression, cette génération a dû, en elle-même et autour d’elle, restaurer, à partir de ses seules négations, un peu de ce qui fait la dignité de vivre et de mourir. \n但我们的使命也许更伟大，那就是要防止这个世界分崩离析。这一代人继承的历史是腐化的，混杂着失败的革命、疯狂的技术、死去的神祇和疲弱的意识形态。在这样的历史之中，政权能摧毁今天的一切，却并不能说服，智者自贬身价成为了仇视和压迫的奴役。这代人不得不带着独有的清醒，为自身和周围修复一点点生存和死亡的尊严。\nDevant un monde menacé de désintégration, où nos grands inquisiteurs risquent d’établir pour toujours les royaumes de la mort, elle sait qu’elle devrait, dans une sorte de course folle contre la montre, restaurer entre les nations une paix qui ne soit pas celle de la servitude, réconcilier à nouveau travail et culture, et refaire avec tous les hommes une arche d’alliance. Il n’est pas sûr qu’elle puisse jamais accomplir cette tâche immense, mais il est sûr que partout dans le monde, elle tient déjà son double pari de vérité et de liberté, et, à l’occasion, sait mourir sans haine pour lui. C’est elle qui mérite d’être saluée et encouragée partout où elle se trouve, et surtout là où elle se sacrifie. C’est sur elle, en tout cas, que, certain de votre accord profond, je voudrais reporter l’honneur que vous venez de me faire.\n在这个即将分崩离析的世界面前，审查官建立的恐怕是永久死亡的国度。这代人明白，在与时间疯狂赛跑的同时，他们应在不同民族间建立不屈于任何强权的和平，调和劳作与文化的关系，在每个人心里重建和解的桥梁。能否完成这一使命还是未知数，但在世界各处，他们祭起真理和自由的大旗，必要时，愿意为此牺牲而无怨无悔。这一代人在哪里都值得敬重、值得鼓励，尤其是在他们献身的地方。总之，应该是向他们，献上你们刚刚赋予我的荣耀，我想你们也会深有同感。\nDu même coup, après avoir dit la noblesse du métier d’écrire, j’aurais remis l’écrivain à sa vraie place, n’ayant d’autres titres que ceux qu’il partage avec ses compagnons de lutte, vulnérable mais entêté, injuste et passionné de justice, construisant son œuvre sans honte ni orgueil à la vue de tous, sans cesse partagé entre la douleur et la beauté, et voué enfin à tirer de son être double les créations qu’il essaie obstinément d’édifier dans le mouvement destructeur de l’histoire. \n阐述完作家职业的高贵，我还想藉此机会谈谈作家的本职。除了战斗者他们没有其他头衔，他们脆弱却执着，虽得不到公正却向往公正，众目睽睽之下不卑不亢地构思，永远在痛苦与美好之间徘徊，在历史毁灭性的运动中以及其自身双重的存在里，抽丝剥茧般最终完成自己的创造。\nQui, après cela, pourrait attendre de lui des solutions toutes faites et de belles morales ? La vérité est mystérieuse, fuyante, toujours à conquérir. La liberté est dangereuse, dure à vivre autant qu’exaltante. Nous devons marcher vers ces deux buts, péniblement, mais résolument, certains d’avance de nos défaillances sur un si long chemin.\n除此之外，谁又能指望从作家那里得到现成的答案和美丽的道德信条呢？真理是难以捉摸、稍纵即逝、永远有待追逐的。自由之路险境重重、难以生存却又令人振奋。我们必须朝着真理和自由的目标前进，艰苦卓绝却坚定不移，路漫漫却要勇往直前。\nQuel écrivain, dès lors oserait, dans la bonne conscience, se faire prêcheur de vertu ? Quant à moi, il me faut dire une fois de plus que je ne suis rien de tout cela. Je n’ai jamais pu renoncer à la lumière, au bonheur d’être, à la vie libre où j’ai grandi. \n从此，哪个有着自知之明的作家还敢自诩为道德说教者？至于我本人，再次重申，我绝不扮演这样的角色。我从不曾放弃过追求光明，感受存在的幸福，向往少年时自由自在的生活。\nMais bien que cette nostalgie explique beaucoup de mes erreurs et de mes fautes, elle m’a aidé sans doute à mieux comprendre mon métier, elle m’aide encore à me tenir, aveuglément, auprès de tous ces hommes silencieux qui ne supportent, dans le monde, la vie qui leur est faite que par le souvenir ou le retour de brefs et libres bonheurs.\n这种种贪恋之情尽管也让我犯了不少错误，却也帮助我更好地理解了我的职业，支持我不假思索地站在那些沉默者一边。对他们而言，要在这世上活下去，唯有靠那一点点幸福、自由却又短暂的回忆。\nRamené ainsi à ce que je suis réellement, à mes limites, à mes dettes, comme à ma foi difficile, je me sens plus libre de vous montrer pour finir, l’étendue et la générosité de la distinction que vous venez de m’accorder, plus libre de vous dire aussi que je voudrais la recevoir comme un hommage rendu à tous ceux qui, partageant le même combat, n’en ont reçu aucun privilège, mais ont connu au contraire malheur et persécution.\n由此回到现实中的我，回到我的局限、我的债务，回到我艰难的信仰上来。作为结束，我感到能更坦然地向诸位表达我的情意。这份殊荣，我愿意接受并与所有同我一起战斗的人分享，他们从未得到过任何一点奖赏，却唯独受尽了折磨与不幸。\nIl me restera alors à vous en remercier, du fond du cœur, et à vous faire publiquement, en témoignage personnel de gratitude, la même et ancienne promesse de fidélité que chaque artiste vrai, chaque jour, se fait à lui-même, dans le silence.\n最后，请再次接受我发自内心的感激和公开忠诚的承诺。这一古老而忠诚的承诺，是每一个真正的艺术家每天面对自己默默必行的功课。\n","categories":["Article"],"tags":["阿尔贝·加缪"]}]