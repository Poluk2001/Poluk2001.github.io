[{"title":"一份简短的Git学习记录","url":"/2022/10/share-git.html","content":"一：Git介绍\nGit是免费的开源软件，用于分布式版本控制：跟踪任何一组文件的变化，通常用于协调软件开发过程中合作开发源代码的程序员之间的工作。它的目标包括速度、数据完整性和对分布式、非线性工作流程的支持（在不同系统上运行的数千个并行分支）。\n\n\n\n版本控制  版本控制(Revision control)是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。\n团队协作  从单兵作战转换为团队作战\n\n二：Git的安装Git官网：Git官网Git安装教程：安装教程\n安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：\n$ git config --global user.name &quot;John Doe&quot;\n$ git config --global user.email johndoe@example.com\n\n三：初始化$ git init\n\n\n选择我们所需要创建&#x2F;管理的git文件夹进行初始化，如图：\n\n\n\n查看初始化过后的文件夹\n\n我们可以手动去磁盘管理里面进行查看是否隐藏文件夹或者利用git的ls -a 去查看，如图：\n\n\nGit工作区，暂存区和版本库\n\n\n托管平台：\n\n局域网(内网)\ngitlab\n\n\n公网(外网)\nGitlab\nGithub\ngitee\n\n\n\n四：添加暂存区\n添加暂存区:\n\n$ git add test.txt\n\n\n查看暂存区的状态:\n\n$ git status\nOn branch master\n\nNo commits yet\n\nChanges to be committed:\n  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)\n        new file:   test.txt\n\n\n将上传到暂存区的文件删除:\n\n$ git rm --cached 文件名\n\n\n将工作区的全部文件上传到暂存区:\n\n$ git add .\n\n五：提交到本地库\n将暂存区代码提交到本地仓库中:\n\n$ git commit -m &quot;填写注释内容&quot;\n\n当我们在此使用git status 查看时有“clean”关键字即代表暂存区无内容\n$ git status\nOn branch master\nnothing to commit, working tree clean\n\n\n查看提交的历史记录:\n\n$ git log\ncommit 2e6ab1b4eb40dc5b70a06e971c72d7beaf3b3e42 (HEAD -&gt; master)\nAuthor: Poluk &lt;Poluk2001@163.com&gt;\nDate:   Sat Nov 12 23:29:59 2022 +0800\n\n    这是第二次提交\n\ncommit 6f84ca758c44b7405337818e8b53c71bc7412e53\nAuthor: Poluk &lt;Poluk2001@163.com&gt;\nDate:   Sat Nov 12 23:01:12 2022 +0800\n\n    这是第一次提交\n\n六：回退版本利用reset回退版本\n回退到上一次提交的版本:\n\n$ git reset --hard HEAD^\nHEAD is now at 6f84ca7 这是第一次提交\n\n\n回退到上上次提交的版本:\n\n$ git reset --hard HEAD~2\n$ git reset --hard HEAD ^^\n\n\n\n查看所有操作记录:\n\n$  git reflog\n6f84ca7 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^\n2e6ab1b HEAD@&#123;1&#125;: commit: 这是第二次提交\n6f84ca7 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): 这是第一次提交\n\n\n根据commit id信息回退版本:\n\n$ git reset --hard commit id\n\n如图：\n\n回退版本到暂存区:\n\n$ git reset --soft commit id\n\n\nhard和soft回退版本的区别:\n\n\n\nsoft功能作用：\n\n重新写“提交记录”\n把已提交到master的文件回退到暂存区，并且把新修改过后的同一个文件add到暂存区合并，一起再提交到master中，这样日志中就只有一个同文件的提交记录了。\n\n\n利用revert回退版本\nrevert回退方式\n\n$ git revert head\n\n\n\ngit reset: 是回滚到对应的commit-id,相当于是删除了commit-id以后的所有的提交，并且不会产生新的commit-id记录，如果要推送到远程服务器的话，需要强制推送-f\ngit revert: 是反做撤销其中的commit-id,然后重新生成一个commit-id。 本身不会对其他的提交commit-id产生影响，如果要推送到远程服务器的话,就是普通的操作git push就好了\nPS: reset –hard 和 revert 都会退回到工作区，但是revert是创建一个新的commit id 并且HEAD指针指向新生成的id，而reset –hard是删除当前commit id并且 HEAD指针直接指向上一个id\n\n七：分支\n查看分支(星号代表当前所在的分支):\n\n$ git branch\n* master\n\n\n创建分支:\n\n$ git branch 分支名\n\n\n切换分支:\n\n$ git checkout 分支名\nSwitched to branch &#39;分支名&#39;\n\n\n合并分支:\n\n$ git merge 分支名\n\n\n删除分支:\n\n合并完分支后，先切换到别的分支在进行删除操作：\n$ git branch -d 分支名\nDeleted branch newlist (was f667656).\n\n\n合并冲突:\n  我们在不同的分支表示不同的工作区，分别在不同的分支上进行add和commit最终的文件内容也会因为分支不同而导致内容不同。  解决合并冲突就是git也不知道保留哪个内容或者都需要保留，所以需要我们手动解决合并冲突。\n\n\n示意图：\n八：添加远程仓库的地址\n创建远程仓库地址:\n\n\n\n添加远程仓库的地址:\n\n$ git remote add origin git@github.com:Github用户名/仓库名.git\n#范例如下:\n$ git remote add origin git@github.com:Poluk2001/testgit.git\n\ngit remote add 是命令，origin 是远程仓库名字，这是Git默认的叫法，也可以改成别的。\n\n查看远程仓库名:\n\n$ git remote -v\n\n\n移除远程仓库名:\n\n$ git remote remove origin\n\n\n将本地仓库推送到远程仓库:\n\n$ git push -u origin master\n\ngit push 是推送到远程仓库命令，-u 是记录当前地址，下次直接输入git push 命令即可；\n\n拉取远程最新仓库:\n\n$ git pull #origin master\n\norigin master 可以不用写进去，所以这里我加了#，因为在之前默认使用-u 选项，所以git会自动识别我们之前默认的仓库名以及分支。\n\n将远程仓库克隆到本地:\n\n$ git clone git@github.com:Poluk2001/testgit.git(仓库地址)\n\n九：团队协作与冲突\n添加协作者的Github账户:\n 用户可以有拉取和克隆远程仓库的权限，但是推送权限只有仓库创建者所拥有，我们需要在远程仓库的setting中添加合作者：\n\n点击左侧Collaboratos\n点击Add people\n搜索需要添加合作的Github用户\n将生成的Pending Invite发送给需要的协作的用户，对方进行点击即可，即可完成合作邀请操作\n\n\n\n\n\n合并冲突:\n\n在与团队协作当中我们会时常遇到合并冲突，我们需要与另一个人进行沟通，进行手动合并\n\n在每次写代码之前，我们都要使用git pull命令来拉取仓库最新地址，保证我们本地仓库代码与远程仓库代码一致。\n\n\n将本地仓库的分支推送到远程仓库:\n\n$ git push origin 本地分支名:远程分支名\n\n\n将远程仓库分支拉取到本地仓库:\n\n$ git pull origin 远程分支名\n\n\n删除远程仓库的分支:\n\n$ git push origin :远程分支名\n\n十：跨团队协作\n\n","categories":["Note"],"tags":["Git","Github"]},{"title":"二叉树的刷题笔记","url":"/2023/05/share-BinaryTree.html","content":"最近在代码随想录上学习各种算法并做了一些记录\n\n二叉树的种类在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。\n满二叉树定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。 也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。\n如图：\n\n完全二叉树定义：完全二叉树是由满二叉树而引出来的，对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。\n如图：\n\n二叉搜索树定义：二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：\n\n若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n任意节点的左、右子树也分别为二叉查找树；\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(logn) 。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。\n如图：\n\n平衡二叉搜索树定义：平衡二叉搜索树（英语：Balanced Binary Search Tree）是一种结构平衡的二叉搜索树，它是一种每个节点的左右两子树高度差都不超过1的二叉树。它能在 O(logn) 内完成插入、查找和删除操作，最早被发明的平衡二叉搜索树为AVL树\n常见的平衡二叉搜索树有：\n\nAVL树\n红黑树\n\n如图：\n\n最后一棵树左子树高度为2，右子树高度为0，高度差的绝对值大于1了\n二叉树的存储方式二叉树可以链式存储，也可以顺序存储。\n那么链式存储方式就用指针， 顺序存储的方式就是用数组。\n顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。\n链式存储如图：\n\n顺序存储如图：\n\n如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n二叉树的遍历方式二叉树主要有两种遍历方式：\n\n深度优先遍历：先往深走，遇到叶子节点再往回走。\n\n前序遍历（递归法，迭代法）\n中序遍历（递归法，迭代法）\n后序遍历（递归法，迭代法）\n\n\n广度优先遍历：一层一层的去遍历。\n\n层次遍历（迭代法）\n\n\n\n这两种遍历是图论中最基本的两种遍历方式\n\n做二叉树相关题目时，我们经常使用递归方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。\n栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。\n而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。\n二叉树的定义public class TreeNode &#123;\n    int val;\n      TreeNode left;\n      TreeNode right;\n      TreeNode() &#123;&#125;\n      TreeNode(int val) &#123; this.val = val; &#125;\n      TreeNode(int val, TreeNode left, TreeNode right) &#123;\n            this.val = val;\n            this.left = left;\n            this.right = right;\n      &#125;\n&#125;\n\n二叉树的深度优先遍历递归法对应LeetCode的题目：\n\n144.二叉树的前序遍历\n145.二叉树的后序遍历\n94.二叉树的中序遍历\n\n如果对递归不清楚的可以先去看一段视频了解一下：递归函数\n写递归的三要素：\n\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n\n以前序遍历为例：\n\n确定递归函数的参数和返回值，因为要打印出前序遍历节点的数值，所以参数里需要传入List来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：\n\npublic void preorder(TreeNode root, List&lt;Integer&gt; result)\n\n\n确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：\n\nif(root == null) &#123;return;&#125;\n\n\n确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：\n\n    result.add(root.val);\n    preorder(root.left, result);\n    preorder(root.right, result);\n\nTips：前中序遍历需将result.add(root.val)写到正确的位置\n前序遍历// 前序遍历·递归·LC144_二叉树的前序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n\n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    &#125;\n&#125;\n\n中序遍历// 中序遍历·递归·LC94_二叉树的中序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        inorder(root, res);\n        return res;\n    &#125;\n\n    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        inorder(root.left, list);\n        list.add(root.val);             // 注意这一句\n        inorder(root.right, list);\n    &#125;\n&#125;\n\n后序遍历// 后序遍历·递归·LC145_二叉树的后序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        postorder(root, res);\n        return res;\n    &#125;\n\n    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        postorder(root.left, list);\n        postorder(root.right, list);\n        list.add(root.val);             // 注意这一句\n    &#125;\n&#125;\n\n迭代法对应LeetCode的题目：\n\n144.二叉树的前序遍历\n145.二叉树的后序遍历\n94.二叉树的中序遍历\n\n递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n前序遍历前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子，这样出栈的时候才是中左右的顺序。\n动画示意如下：\n代码如下：\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n         //建List用来存放栈弹出的结果\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();   \n        if(root == null) return result;\n        //建栈\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();  \n        //将根节点root入栈\n        stack.push(root);                       \n        while(!stack.isEmpty())&#123;       \n             //将出栈的值用node记录下来，并保存到result中        \n            TreeNode node = stack.pop();       \n            result.add(node.val);         \n            //判断被记录的node右子树值是否为空,将此节点的右子树的值入栈  \n            if(node.right != null) stack.push(node.right);         \n            //同右子树逻辑一样\n            if(node.left != null) stack.push(node.left);\n        &#125;\n        return result;                        \n    &#125;\n&#125;\n\n中序遍历为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：\n\n处理：将元素放进result数组中\n访问：遍历节点\n\n分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。\n动画示意如下：\n\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        if (root == null) return result;\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        TreeNode cur = root;\n        while (cur != null || !stack.isEmpty())&#123;\n            //用来访问最底层\n           if (cur != null)&#123;       \n            //将访问的节点放入栈中\n               stack.push(cur);    \n               cur = cur.left;      //左\n           &#125;else&#123;\n               //从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）\n               cur = stack.pop();   \n               result.add(cur.val);               //中\n               cur = cur.right;                      //右\n           &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n后序遍历后序遍历与前序遍历的关系：\n\n前序遍历：中左右\n后序遍历：左右中\n\n如果从前序遍历得到后序遍历，首先调换前序遍历的左，右的位置，得到中，右，左，然后再翻转，得到左，右，中。\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n         //建List用来存放栈弹出的结果\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();   \n        if(root == null)&#123;\n            return result;\n        &#125;\n         //建栈\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();  \n         //将根节点root入栈\n        stack.push(root);  \n        while(!stack.isEmpty())&#123;             \n             //将出栈的值用node记录下来，并保存到result中  \n            TreeNode node = stack.pop();       \n            result.add(node.val);\n            //注意先左，后右               \n            if(node.left != null) stack.push(node.left);\n            if(node.right != null) stack.push(node.right);\n        &#125;\n        //处理完后,结果集中的结果是中右左，对结果进行翻转后得到左右中\n        Collections.reverse(result);            \n        return result;                         \n    &#125;\n&#125;\n\n二叉树的广度优先遍历二叉树的层序遍历接下来我们再来介绍二叉树的另一种遍历方式：层序遍历。\n102.二叉树的层序遍历力扣题目链接\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。\n思路：\n需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。\n而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。\n动画示意如下：\n\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;\n        //用一个二维数组来接受最终结果\n        List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();  \n        //创建一个队列用来存放二叉树节点\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();    \n        //判断是否为空\n        if(root == null) return resList;  \n        //将根节点入队\n        que.offer(root);                                       \n        while(!que.isEmpty())&#123;\n             //创建数组来存放出队的值\n            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;();  \n            //记录队列的大小\n            int len = que.size();     \n            //控制队列的大小从而来控制出队的数，达到同一层的数正确的记录到一个数组中              \n            while(len &gt; 0)&#123;                                     \n                TreeNode tmpNode = que.poll();\n                itemList.add(tmpNode.val);\n                if(tmpNode.left != null) que.offer(tmpNode.left);\n                if(tmpNode.right != null) que.offer(tmpNode.right);\n                //每出队一个值，队列大小-1，\n                len--;                                          \n            &#125;\n            resList.add(itemList);\n        &#125;\n        return resList;\n    &#125;\n&#125;\n\n107.二叉树的层次遍历 II力扣题目链接\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n思路：\n相对于102.二叉树的层序遍历，就是最后把result数组反转一下就可以了。\nclass Solution &#123; \n    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;\n        // 利用链表可以进行 O(1) 头部插入, 这样最后答案不需要再反转\n        LinkedList&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();          \n        if(root != null) que.offer(root);                            \n        while(!que.isEmpty())&#123;\n            List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;();  \n            int len = que.size();                               \n            for(int i = 0; i &lt; len; i++)&#123;\n                TreeNode node =que.poll();\n                temp.add(node.val);\n                if(node.left != null) que.offer(node.left);\n                if(node.right != null) que.offer(node.right);\n            &#125;\n            ans.addFirst(temp);     //将新遍历的结果插入到链表头部\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n199.二叉树的右视图力扣题目链接\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n思路：\n层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。\nclass Solution &#123;\n    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;\n        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();\n        if(root == null) return list;\n        que.offer(root);\n        while(!que.isEmpty())&#123;\n            int levelSize = que.size();\n            for(int i = 0; i &lt; levelSize; i++)&#123;\n                TreeNode pollNode = que.poll();\n                //对栈的循环只将每层中的最后一个元素加入结果集就行，实在不理解可以画一个二叉树模拟一遍\n                if(i == levelSize - 1) list.add(pollNode.val);\n                if(pollNode.left != null) que.offer(pollNode.left);\n                if(pollNode.right != null) que.offer(pollNode.right);\n            &#125;\n        &#125;\n        return list;\n    &#125;\n&#125;\n\n637.二叉树的层平均值力扣题目链接\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n思路:\n本题就是层序遍历的时候把一层求个总和在取一个均值。\nclass Solution &#123;\n    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;\n        List&lt;Double&gt; list = new ArrayList&lt;Double&gt;();\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();\n        if(root == null) return list;\n        que.offer(root);\n        while(!que.isEmpty())&#123;\n            int levelSize = que.size();\n            //定义一个double类型的变量存放每层的平均值\n            double levelSum = 0.0;\n            for(int i = 0; i &lt; levelSize; i++)&#123;\n                TreeNode pollNode = que.poll();\n                //将弹出队列的元素加到变量中\n                levelSum += pollNode.val;\n                if(pollNode.left != null)  que.offer(pollNode.left);\n                if(pollNode.right != null) que.offer(pollNode.right);\n            &#125;\n            list.add(levelSum / levelSize);\n        &#125;\n        return list;\n    &#125;\n&#125;\n\n429.N叉树的层序遍历力扣题目链接\n给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。\n思路:\n这道题依旧是模板题，只不过一个节点有多个孩子了\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n        Queue&lt;Node&gt; que = new LinkedList&lt;&gt;();\n        if(root == null) return ans;\n        que.offer(root);\n        while(!que.isEmpty())&#123;\n            int levelSize = que.size();\n            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n            for(int i = 0; i &lt; levelSize; i++)&#123;\n                Node pollNode = que.poll();\n                //将从队列弹出的孩子节点依次入队\n                for(Node node : pollNode.children) que.offer(node);\n                list.add(pollNode.val);\n            &#125;\n            ans.add(list);\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n515.在每个树行中找最大值力扣题目链接\n您需要在二叉树的每一行中找到最大的值。\n思路：\n层序遍历，取每一层的最大值\nclass Solution &#123;\n    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;\n        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();\n        if(root == null) return ans;\n        que.offer(root);\n        while(!que.isEmpty())&#123;\n            int levelSize = que.size();\n            int levelMax = Integer.MIN_VALUE;\n            for(int i = 0; i &lt; levelSize; i++)&#123;\n                TreeNode pollNode = que.poll();\n                //利用max函数判断levelMax的值和出队的值谁大\n                levelMax = Math.max(levelMax,pollNode.val);\n                if(pollNode.left != null) que.offer(pollNode.left);\n                if(pollNode.right != null) que.offer(pollNode.right);\n            &#125;\n            ans.add(levelMax);\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n116.填充每个节点的下一个右侧节点指针力扣题目链接\n给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n思路：\n本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了\n迭代：\nclass Solution &#123;\n    public Node connect(Node root) &#123;\n        if(root == null) return root;\n        Deque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();\n        queue.offer(root);\n        while(!queue.isEmpty())&#123;\n            int n = queue.size();\n            for(int i = 0; i &lt; n; i++)&#123;\n                Node node = queue.pop();\n                 if(i != n-1) node.next = queue.peek();\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n        &#125;\n        return root;\n    &#125;\n&#125;\n\n递归：\nclass Solution &#123;\n    public Node connect(Node root) &#123;\n        if(root == null) return null;\n        DFS(root);\n        return root;\n    &#125;\n\n    public void DFS(Node root)&#123;\n        //递归退出条件，需要用到父节点来操作.next指向右邻居，所以最后一次递归执行是当root到叶子结点的上一层对叶子结点进行操作\n        if(root.left == null || root.right == null)&#123;\n            return;\n        &#125;\n        //root的左孩子肯定有右邻居\n        root.left.next = root.right;\n        //如果父亲节点有右邻居，那么父节点root的右孩子一定也有右邻居\n        if(root.next != null)&#123;\n            root.right.next = root.next.left;\n        &#125;\n        //前序遍历\n        DFS(root.left);\n        DFS(root.right);\n    &#125;\n&#125;\n\n117.填充每个节点的下一个右侧节点指针II力扣题目链接\n思路：\n这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道\nclass Solution &#123;\n    public Node connect(Node root) &#123;\n        if(root == null) return root;\n        Deque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();\n        queue.offer(root);\n        while(!queue.isEmpty())&#123;\n            int n = queue.size();\n            for(int i = 0; i &lt; n; i++)&#123;\n                Node node = queue.pop();\n                 if(i != n-1) node.next = queue.peek();\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n        &#125;\n        return root;\n    &#125;\n&#125;\n\n104.二叉树的最大深度力扣题目链接\n给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n思路：\n使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。\n在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：\n\n递归：\nclass Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if(root == null)&#123;\n            return 0;\n        &#125;\n        //计算左子树深度\n        int leftHight = maxDepth(root.left);\n        //计算右子树深度\n        int rightHight = maxDepth(root.right);\n        //从左子树和右子树深度中选一个最大的值和当前节点+1，并且返回maxHight\n        return Math.max(leftHight,rightHight) + 1;\n    &#125;\n&#125;\n\n迭代：\nclass Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if(root == null) return 0;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        int depth = 0;\n        while(!queue.isEmpty())&#123;\n            int size = queue.size();\n            for(int i = 0; i &lt; size; i++)&#123;\n                TreeNode pollNode = queue.poll();\n                if(pollNode.left != null) queue.offer(pollNode.left);\n                if(pollNode.right != null) queue.offer(pollNode.right);\n            &#125;\n            depth++;\n        &#125;\n        return depth;\n    &#125;\n&#125;\n\n111.二叉树的最小深度力扣题目链接\n相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。\n需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点\nclass Solution &#123;\n    public int minDepth(TreeNode root) &#123;\n        if(root == null) return 0;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        int depth = 0;\n        while(!queue.isEmpty())&#123;\n            int size = queue.size();\n            depth++;\n            for(int i = 0; i &lt; size; i++)&#123;\n                TreeNode pollNode = queue.poll();\n                //如果当前节点的左右孩子都为空，直接返回最小深度\n                if(pollNode.left == null &amp;&amp; pollNode.right == null) return depth;\n                if(pollNode.left != null) queue.offer(pollNode.left);\n                if(pollNode.right != null) queue.offer(pollNode.right);\n            &#125;\n        &#125;\n        return depth;\n    &#125;\n&#125;\n\n","categories":["Note"],"tags":["LeetCode","算法"]},{"title":"分享一点自己在 B 站收藏的“比较有质量”的课程-第二弹","url":"/2024/05/share-bilibili-2.html","content":"随便说点在23年4月12日，我分享了第一篇关于课程分享的文章，截止到今天为止收获了2万的点击、1877人的收藏、109人的感谢，能在V2EX里获得这么大的关注度是我的荣幸\n其实前段时间就想再整理一篇“质量”课程分享的List，终于在今天花了些时间去整理出来了，这次不仅包含了计算机，还包含了哲学、文学、艺术、数学等一点相关的课程\n而我本身写这个List也是单纯做个分享，不能保证在本文列举的课程都是非常非常的高质量。大家如果以后想具体学某个的时候可以先从这篇大概看看，如果觉得都不太合适，那么再自行查找资源也是可行的\n计算机类相关还是强烈推荐CS自学指南的课程，这里作为小补充。\n关于南京大学的计算机课程，有几门课程每年都有最新的，具体在BiliBili自行搜索关键字，例如：蒋炎岩、黄宇、徐经纬(目前只了解这三位每年都上传新录播)\n不知道下次分享是在什么时候了，希望各位在明年的这个时间可以更进一步，祝各位身体健康，事业顺利捏！\n计算机相关\n教你写一个简单的CPU\n\n2020年春季:南京大学计算机系统基础PA在线课-汪亮\n\n《智能计算系统-从深度学习到大模型》\n\n耶路撒冷希伯来大学:从零开始构建现代计算机(GPT翻译)\n\n普林斯顿大学-计算机科学:算法、理论和机器(GPT翻译)\n\n湖南大学:2024计科拔尖班《编译原理》\n\n计算机体系结构（2024年春）\n\nCS537:操作系统导论Spring2018(英)\n\n中山大学:操作系统原理-2024\n\nCMU15-440:分布式系统(英)\n\nCMU15-150:函数式编程Summer2023(机翻)\n\n台湾科技大学:计算机组成2023-刘一宇\n\nKAISTCS420:编译器设计2020Spring(机翻)\n\nCornell CS5412:云计算(机翻)\n\n国科大:计算机体系结构胡伟武、汪文祥\n\nCMU15213&#x2F;15513-2023Spring:深入理解计算机系统(英)\n\nUPen-CIS-5650:GPU Programming and Architecture - Fall 2023(GPT翻译)\n\nUCBerkeley-CS61C:计算机体系结构(GPT翻译)\n\n数字电路(对应的MIT数电)-UP主讲解\n\nStanford-CS107:计算机组织与系统\n\n北京大学肖臻老师《区块链技术与应用》公开课\n\nStanford:密码学(有翻译)\n\n台湾大学:信号与系统-李琳山\n\n威廉玛丽学院:计算机体系结构建模与仿真(英)\n\n中文讲解版-CMU15-445:数据库内核\n\n清华大学计算机系:数据库管理系统-李国良\n\n新火公开课-密码学基础系列课程\n\n自制双语字幕-计算机教育缺失的一课(2020) \n\n中文精翻 2024·CS61B\n\n香港科技大学:高级算法 &amp; Advanced Algorithms\n\n2024 Rust现代实用教程\n\n计算机程序的构造和解释 (SICP) Python版 教程（录制持续更新中）\n\n信号与系统漫谈\n\n嵌入式系统-南开大学李庆诚教授-2024春\n\n分布式密码学:Dora Dōjō x THUBA\n\n\n数学相关\n北大丘维声教授清华高等代数课程1080P高清修复版\n\n中国科学技术大学-数学分析(B1)-程艺老师\n\n【北京大学公开课】数学分析（上下全112讲无级数部分）\n\n复变函数(复分析)【中英双字】已完结\n\n数学分析陈纪修无障碍重制版\n\n2020齐震宇老师微積分02班\n\n高等代数学-复旦大学-谢启鸿-高清\n\n离散数学-东北大学\n\n统计学-个人UP主\n\n\n哲学相关\n中国人民大学:西方哲学史-张志伟\n\n赵林、邓晓芒-西方哲学史(旧版)\n\n台湾大学:逻辑学-傅皓政\n\n康德专题研究-邓晓芒\n\n劳动关系学院:美学原理-2021年春-杨宁\n\n符号学入门\n\n\n人文&#x2F;艺术&#x2F;建筑相关&#x2F;电影&#x2F;社会学&#x2F;摄影\n【MIT】全球建筑史（4.605 A Global History of Architecture）（英文）\n\n现代社会理论基础-中英字幕\n\n中英双字-艺术史速成课\n\n贡布里希《艺术的故事》视频解说版\n\n摄影指导公开课-VFS&#x2F;北电毕业生\n\n导演公开课-北电&#x2F;VFS毕业生\n\n劳动关系学院:文学理论-2021年秋-杨宁\n\n劳动关系学院:西方文论-2021年秋-杨宁\n\n周传基讲电影\n\n\n","categories":["Note"],"tags":["分享"]},{"title":"分享一点自己在 B 站收藏的“比较有质量”的课程","url":"/2023/04/share-bilibili.html","content":"随便说一点   我自己在日常会整理、收藏一些比较有质量的课程，特别想分享在这里，分享给有需要的人！。\n   我分享的列表课程并不能代替那些质量公开课。 每个人水平不同，我分享的列表中也有一些985大学在校生讲的而且讲的非常不错，我只是分享出来，帮助有需要和有需求的人。\n   \n\n   国内的公开课数量和质量也在大大增加，比如南京大学的几位老师近几年都在平台上分享自己的课程实录，甚至上课的时候同时开直播，与南大学子一起上课。\n   本来也想整理一些有质量的Up主的，但是我的账号关注数有一点小多，暂时就不整理分享了。如果各位大佬有推荐的UP,以及质量课程可以发在评论区一起交流。收藏不等于学会，同时也祝我们国内更好的课程越来越多。\n   第一次在这里做分享，本人比较菜，有些课程分类可能不正确，但是尽力了，希望各位轻喷！\n操作系统&#x2F;计算机组成\n操作系统实现\n操作系统速成-2022秋冬朋辈辅学录播\nCSAPP-深入理解计算机系统-讲解\n“一生一芯”\nMIT6.828&#x2F;6.S081操作系统课程教程\n从零开始自制操作系统\n2023 南京大学 “操作系统：设计与实现” (蒋炎岩)\n厦门大学-操作系统原理（2022春）\n现代操作系统：原理与实现（上海交通大学）\n【操作系统原理】清华大学陈渝教授\n深入理解计算机系统—个人讲解\n深入理解计算机系统-CSAPP重点导读\nDr.Dng陪跑CSAPP: bigONE《深入理解计算机系统》\nCS162操作系统-精译(更新中)\n台湾清华大学 - 操作系统 Operating Systems - 黄能富教授\n\n编译相关&#x2F;软件分析\n南京大学《软件分析》课程2020\n手写一个 RISC-V 编译器！初学者友好的实战课程\n南京大学软件学院编译原理课程\n\n数据结构&#x2F;算法相关\n东北大学：2021～2022春季学期算法设计与分析\n南京大学《2023算法设计与分析》- 黄宇\n南京大学《2023算法设计与分析》- 徐经纬\n数据结构与算法基础（青岛大学-王卓）\n跟懒猫老师快乐学数据结构\n\n计算机网络\n计算机网络-通熟易懂讲解每个知识要点\n中科大郑烇、杨坚全套-计算机网络（自顶向下方法)\n计算机网络微课堂\n\n程序语言&#x2F;编程语言\n计算机程序的构造与解释（SICP, Python版）\n计算机语言 x86汇编语言：从实模式到保护模式（操作系统引导课）\n程序语言理论与实现\n【CS公开课】计算机程序的构造和解释（SICP）\n精译-UC Berkeley 公开课-CS61A【计算机程序的构造和解释】 (Spring 2021)\n\n软件工程\n南京大学-2023软件工程与计算 I\n\n数据库\n数据库系统（DBMS）\nCMU15-445-精译(更新中)\n\n并行程序设计\n并行程序设计 谭光明\n高性能并行编程与优化\n新竹清华大学：并行计算与并行编程课程\n\n工具\n浙江大学：「实用技能拾遗」2023 春夏朋辈辅学\nObsidian公开课\n\n不会分类的or列表太少不至于分类的\n硬件茶谈：硬核科普\n精读c++primer\n计算机图形学游戏方向-2023年春季第2次迭代-谭剑\nLinux 文件系统九讲-陈硕\nDDIA 读书逐章分享\n机器学习-白板推导系列\n陈明-南京大学23春-面向对象编程基础\n每个程序员都应该知道的内存知识 (带你走读Ulrich Drepper的经典论文)\nLinux 操作系统 核心設計 ||完结\n\n","categories":["Note"],"tags":["分享"]},{"title":"加缪获颁诺贝尔文学奖致谢辞(中法)","url":"/2023/06/Albert-Camus-NobelTalk.html","content":"Sire, Madame, Altesses Royales, Mesdames, Messieurs,\n国王陛下，王后，各位殿下，女士们、先生们，\nEn recevant la distinction dont votre libre Académie a bien voulu m’honorer, ma gratitude était d’autant plus profonde que je mesurais à quel point cette récompense dépassait mes mérites personnels.\n秉承自由精神的瑞典皇家科学院将这份殊荣授予我，万分感激之余更添万般惶愧。\nTout homme et, à plus forte raison, tout artiste, désire être reconnu. Je le désire aussi. Mais il ne m’a pas été possible d’apprendre votre décision sans comparer son retentissement à ce que je suis réellement. \n再理智的人，再理智的艺术家，都渴望被认可。我也不例外。但比起自己所做的一切，这份殊荣是过于沉重了。\nComment un homme presque jeune, riche de ses seuls doutes et d’une œuvre encore en chantier, habitué à vivre dans la solitude du travail ou dans les retraites de l’amitié, n’aurait-il pas appris avec une sorte de panique un arrêt qui le portait d’un coup, seul et réduit à lui-même, au centre d’une lumière crue ? De quel cœur aussi pouvait-il recevoir cet honneur à l’heure où, en Europe, d’autres écrivains, parmi les plus grands, sont réduits au silence, et dans le temps même où sa terre natale connaît un malheur incessant ?\n一个年届不惑却依然满怀困惑的人，创作生涯正值中途，习惯远离朋友、孤独劳作，突然被拦下脚步、推至聚光灯下，四顾无援的他怎能不惊慌失措？他将藉着怎样的心情来接受这份荣耀？此时此刻，就在欧洲，有许多作家，甚至是最伟大的作家，依然默默无闻、乏人问津；此时此刻，就在我出生的地方，依然不幸接连着不幸。\nJ’ai connu ce désarroi et ce trouble intérieur. Pour retrouver la paix, il m’a fallu, en somme, me mettre en règle avec un sort trop généreux. Et, puisque je ne pouvais m’égaler à lui en m’appuyant sur mes seuls mérites, je n’ai rien trouvé d’autre pour m’aider que ce qui m’a soutenu tout au long de ma vie, et dans les circonstances les plus contraires : l’idée que je me fais de mon art et du rôle de l’écrivain. Permettez seulement que, dans un sentiment de reconnaissance et d’amitié, je vous dise, aussi simplement que je le pourrai, quelle est cette idée.\n这样的惶惑不安与内心焦灼于我并不陌生。面对命运的过度垂青，想要重归平静，唯有力求问心无愧。既然我所做的一切与此盛誉颇不相称，别无他法，只有拿一生中最险恶的逆境下支撑我的信念来应对：对艺术的信念，对作家这一角色的信念。借此机会，怀着感激和友善之情，敬请诸位允许我用最简约的方式来阐释这两种信念\nJe ne puis vivre personnellement sans mon art. Mais je n’ai jamais placé cet art au-dessus de tout. S’il m’est nécessaire au contraire, c’est qu’il ne se sépare de personne et me permet de vivre, tel que je suis, au niveau de tous. \n没有艺术，我的生命将不复存在。但我从不将这艺术至于一切之上。如果说艺术对我而言不可或缺，那是因为它决不自我孤立，在与他人同等的层面上，让我本色地活下去。\nL’art n’est pas à mes yeux une réjouissance solitaire. Il est un moyen d’émouvoir le plus grand nombre d’hommes en leur offrant une image privilégiée des souffrances et des joies communes. \n我觉得艺术不应是独自享受，而是一种方法，用它来感动最大多数的人，向他们奉献一种超乎苦痛和普通欢愉之上的形象。\nIl oblige donc l’artiste à ne pas se séparer ; il le soumet à la vérité la plus humble et la plus universelle. Et celui qui, souvent, a choisi son destin d’artiste parce qu’il se sentait différent apprend bien vite qu’il ne nourrira son art, et sa différence, qu’en avouant sa ressemblance avec tous.\n它迫使艺术家不再自我孤立，让他臣服于最卑微、最普遍的真理。通常情况下，选择献身艺术的人，都曾自视与众不同。然而他很快会发现，自己的艺术、自己的与众不同，往往就扎根在与所有人的相似中。\nL’artiste se forge dans cet aller retour perpétuel de lui aux autres, à mi-chemin de la beauté dont il ne peut se passer et de la communauté à laquelle il ne peut s’arracher. C’est pourquoi les vrais artistes ne méprisent rien ; ils s’obligent à comprendre au lieu de juger. Et s’ils ont un parti à prendre en ce monde ce ne peut être que celui d’une société où, selon le grand mot de Nietzsche, ne règnera plus le juge, mais le créateur, qu’il soit travailleur ou intellectuel.\n艺术家就是在自我与他者不断的交往中、在半途不可错过的美景中、在无法抽离的群体中慢慢锤炼自己的。因此，真正的艺术家看重一切，他们逼迫自己去理解，而不仅仅满足当个评判。在这世上，他们必须选择一个阵营，那一定是代表某一集团的立场，据尼采的伟大洞见，在这个集团中，占统治地位的不是判官，而是创造者，他们之中既有劳动者，也有知识分子。\nLe rôle de l’écrivain, du même coup, ne se sépare pas de devoirs difficiles. Par définition, il ne peut se mettre aujourd’hui au service de ceux qui font l’histoire : il est au service de ceux qui la subissent. \n再来谈谈作家的角色，同样责任重大。确切地说，今天的作家不应为制造历史的人服务，而要为承受历史的人服务。\nOu sinon, le voici seul et privé de son art. Toutes les armées de la tyrannie avec leurs millions d’hommes ne l’enlèveront pas à la solitude, même et surtout s’il consent à prendre leur pas. \n否则，他将形影相吊，远离真正的艺术。任何暴君的千百万军队都无法将一个作家从孤独中拯救出来，尤其当这个作家同他们的步调一致的时候。\nMais le silence d’un prisonnier inconnu, abandonné aux humiliations à l’autre bout du monde, suffit à retirer l’écrivain de l’exil chaque fois, du moins, qu’il parvient, au milieu des privilèges de la liberté, à ne pas oublier ce silence, et à le relayer pour le faire retentir par les moyens de l’art.\n相反，一个无名囚徒的沉默，一个被遗弃在世界另一个角落百般受辱的囚徒，就足以将作家从流放中召回，就算这个作家身处优境，只要他不忘记这种沉默，用艺术的种种方式来彰表这种沉默。\nAucun de nous n’est assez grand pour une pareille vocation. Mais dans toutes les circonstances de sa vie, obscur ou provisoirement célèbre, jeté dans les fers de la tyrannie ou libre pour un temps de s’exprimer, l’écrivain peut retrouver le sentiment d’une communauté vivante qui le justifiera, à la seule condition qu’il accepte, autant qu’il peut, les deux charges qui font la grandeur de son métier : le service de la vérité et celui de la liberté. \n我们之中没有一个人能强大到不负这一使命。但在作家漫长一生的境遇中，晦暗也好，腾达也好，在暴君的铁牢中也好，能自在发出声音时也好，只要他尽力做到为真理服务，为自由服务，他就能重新找回勃勃而富有生机的集体情感和支撑。为真理服务，为自由服务，这两条也足以体现作家职业的伟大。\nPuisque sa vocation est de réunir le plus grand nombre d’hommes possible, elle ne peut s’accommoder du mensonge et de la servitude qui, là où ils règnent, font proliférer les solitudes. Quelles que soient nos infirmités personnelles, la noblesse de notre métier s’enracinera toujours dans deux engagements difficiles à maintenir : le refus de mentir sur ce que l’on sait et la résistance à l’oppression.\n既然作家的使命是团结尽可能多的人，那就只有容忍谎言和奴性。这个世界充斥着谎言和奴性，孤独的荒草到处疯长。无论我们每个人有怎样的弱点，作家职业的高贵永远植根在两种艰难的介入中：拒绝谎言，反抗逼迫。\nPendant plus de vingt ans d’une histoire démentielle, perdu sans secours, comme tous les hommes de mon âge, dans les convulsions du temps, j’ai été soutenu ainsi : par le sentiment obscur qu’écrire était aujourd’hui un honneur, parce que cet acte obligeait, et obligeait à ne pas écrire seulement. Il m’obligeait particulièrement à porter, tel que j’étais et selon mes forces, avec tous ceux qui vivaient la même histoire, le malheur et l’espérance que nous partagions. Ces hommes, nés au début de la première guerre mondiale, qui ont eu vingt ans au moment où s’installaient à la fois le pouvoir hitlérien et les premiers procès révolutionnaires, qui furent confrontés ensuite, pour parfaire leur éducation, à la guerre d’Espagne, à la deuxième guerre mondiale, à l’univers concentrationnaire, à l’Europe de la torture et des prisons, doivent aujourd’hui élever leurs fils et leurs œuvres dans un monde menacé de destruction nucléaire. Personne, je suppose, ne peut leur demander d’être optimistes. \n二十多年荒唐的历史进程中，我茫然无助，和许多同龄人一样，在时代的剧烈动荡中，仅靠一种情感模模糊糊地支撑自己：写作的光荣。写作之所以光荣，是因为它有所承担，它承担的不仅仅是写作。它迫使我以自己的方式、凭自己的力量、和这个时代所有的人一起，承担我们共有的不幸和希望。这代人，生于一战之初；二十来岁时伴随早期的工业革命进程，又遭遇希特勒的暴政；随后，仿佛要让他们的经历更完美，发生了西班牙战争、二战、集中营惨剧，整个欧洲满目苍夷、狱祸四起；如今，他们又不得不在核毁灭的阴影下哺育子嗣、成就事业。没人能要求他们更乐观。\nEt je suis même d’avis que nous devons comprendre, sans cesser de lutter contre eux, l’erreur de ceux qui, par une surenchère de désespoir, ont revendiqué le droit au déshonneur, et se sont rués dans les nihilismes de l’époque. Mais il reste que la plupart d’entre nous, dans mon pays et en Europe, ont refusé ce nihilisme et se sont mis à la recherche d’une légitimité. Il leur a fallu se forger un art de vivre par temps de catastrophe, pour naître une seconde fois, et lutter ensuite, à visage découvert, contre l’instinct de mort à l’œuvre dans notre histoire.\n我甚至主张在与之斗争的同时，要理解他们的错误。他们只是因为过度绝望才行不智之举，对时代的虚无主义趋之若鹜。但终究我们中的大多数，不止是在我国，也在整个欧洲，都拒绝这样的虚无主义，致力于追寻合法性。我们需要锻造一种灾难时代生活的艺术，以全新的面貌获得再生，与历史生涯中死亡的本能作斗争。\nChaque génération, sans doute, se croit vouée à refaire le monde. La mienne sait pourtant qu’elle ne le refera pas. \n或许，每一代人都自负能重构这个世界。而我们这一代人却明白这是痴人说梦。\nMais sa tâche est peut-être plus grande. Elle consiste à empêcher que le monde se défasse. Héritière d’une histoire corrompue où se mêlent les révolutions déchues, les techniques devenues folles, les dieux morts et les idéologies exténuées, où de médiocres pouvoirs peuvent aujourd’hui tout détruire mais ne savent plus convaincre, où l’intelligence s’est abaissée jusqu’à se faire la servante de la haine et de l’oppression, cette génération a dû, en elle-même et autour d’elle, restaurer, à partir de ses seules négations, un peu de ce qui fait la dignité de vivre et de mourir. \n但我们的使命也许更伟大，那就是要防止这个世界分崩离析。这一代人继承的历史是腐化的，混杂着失败的革命、疯狂的技术、死去的神祇和疲弱的意识形态。在这样的历史之中，政权能摧毁今天的一切，却并不能说服，智者自贬身价成为了仇视和压迫的奴役。这代人不得不带着独有的清醒，为自身和周围修复一点点生存和死亡的尊严。\nDevant un monde menacé de désintégration, où nos grands inquisiteurs risquent d’établir pour toujours les royaumes de la mort, elle sait qu’elle devrait, dans une sorte de course folle contre la montre, restaurer entre les nations une paix qui ne soit pas celle de la servitude, réconcilier à nouveau travail et culture, et refaire avec tous les hommes une arche d’alliance. Il n’est pas sûr qu’elle puisse jamais accomplir cette tâche immense, mais il est sûr que partout dans le monde, elle tient déjà son double pari de vérité et de liberté, et, à l’occasion, sait mourir sans haine pour lui. C’est elle qui mérite d’être saluée et encouragée partout où elle se trouve, et surtout là où elle se sacrifie. C’est sur elle, en tout cas, que, certain de votre accord profond, je voudrais reporter l’honneur que vous venez de me faire.\n在这个即将分崩离析的世界面前，审查官建立的恐怕是永久死亡的国度。这代人明白，在与时间疯狂赛跑的同时，他们应在不同民族间建立不屈于任何强权的和平，调和劳作与文化的关系，在每个人心里重建和解的桥梁。能否完成这一使命还是未知数，但在世界各处，他们祭起真理和自由的大旗，必要时，愿意为此牺牲而无怨无悔。这一代人在哪里都值得敬重、值得鼓励，尤其是在他们献身的地方。总之，应该是向他们，献上你们刚刚赋予我的荣耀，我想你们也会深有同感。\nDu même coup, après avoir dit la noblesse du métier d’écrire, j’aurais remis l’écrivain à sa vraie place, n’ayant d’autres titres que ceux qu’il partage avec ses compagnons de lutte, vulnérable mais entêté, injuste et passionné de justice, construisant son œuvre sans honte ni orgueil à la vue de tous, sans cesse partagé entre la douleur et la beauté, et voué enfin à tirer de son être double les créations qu’il essaie obstinément d’édifier dans le mouvement destructeur de l’histoire. \n阐述完作家职业的高贵，我还想藉此机会谈谈作家的本职。除了战斗者他们没有其他头衔，他们脆弱却执着，虽得不到公正却向往公正，众目睽睽之下不卑不亢地构思，永远在痛苦与美好之间徘徊，在历史毁灭性的运动中以及其自身双重的存在里，抽丝剥茧般最终完成自己的创造。\nQui, après cela, pourrait attendre de lui des solutions toutes faites et de belles morales ? La vérité est mystérieuse, fuyante, toujours à conquérir. La liberté est dangereuse, dure à vivre autant qu’exaltante. Nous devons marcher vers ces deux buts, péniblement, mais résolument, certains d’avance de nos défaillances sur un si long chemin.\n除此之外，谁又能指望从作家那里得到现成的答案和美丽的道德信条呢？真理是难以捉摸、稍纵即逝、永远有待追逐的。自由之路险境重重、难以生存却又令人振奋。我们必须朝着真理和自由的目标前进，艰苦卓绝却坚定不移，路漫漫却要勇往直前。\nQuel écrivain, dès lors oserait, dans la bonne conscience, se faire prêcheur de vertu ? Quant à moi, il me faut dire une fois de plus que je ne suis rien de tout cela. Je n’ai jamais pu renoncer à la lumière, au bonheur d’être, à la vie libre où j’ai grandi. \n从此，哪个有着自知之明的作家还敢自诩为道德说教者？至于我本人，再次重申，我绝不扮演这样的角色。我从不曾放弃过追求光明，感受存在的幸福，向往少年时自由自在的生活。\nMais bien que cette nostalgie explique beaucoup de mes erreurs et de mes fautes, elle m’a aidé sans doute à mieux comprendre mon métier, elle m’aide encore à me tenir, aveuglément, auprès de tous ces hommes silencieux qui ne supportent, dans le monde, la vie qui leur est faite que par le souvenir ou le retour de brefs et libres bonheurs.\n这种种贪恋之情尽管也让我犯了不少错误，却也帮助我更好地理解了我的职业，支持我不假思索地站在那些沉默者一边。对他们而言，要在这世上活下去，唯有靠那一点点幸福、自由却又短暂的回忆。\nRamené ainsi à ce que je suis réellement, à mes limites, à mes dettes, comme à ma foi difficile, je me sens plus libre de vous montrer pour finir, l’étendue et la générosité de la distinction que vous venez de m’accorder, plus libre de vous dire aussi que je voudrais la recevoir comme un hommage rendu à tous ceux qui, partageant le même combat, n’en ont reçu aucun privilège, mais ont connu au contraire malheur et persécution.\n由此回到现实中的我，回到我的局限、我的债务，回到我艰难的信仰上来。作为结束，我感到能更坦然地向诸位表达我的情意。这份殊荣，我愿意接受并与所有同我一起战斗的人分享，他们从未得到过任何一点奖赏，却唯独受尽了折磨与不幸。\nIl me restera alors à vous en remercier, du fond du cœur, et à vous faire publiquement, en témoignage personnel de gratitude, la même et ancienne promesse de fidélité que chaque artiste vrai, chaque jour, se fait à lui-même, dans le silence.\n最后，请再次接受我发自内心的感激和公开忠诚的承诺。这一古老而忠诚的承诺，是每一个真正的艺术家每天面对自己默默必行的功课。\n","categories":["Article"],"tags":["阿尔贝·加缪"]},{"title":"记录一下最近的思绪","url":"/2023/05/share-myideas.html","content":"最近思绪很多所以想把这些记录一下。\n这学期开学来时常会有焦虑，心情一直在焦虑和平静中起伏。本来这学期是计划找实习，这样能在工业界里学到更多的相关知识，总比待在学习里好。但是在BOSS上，里面大多都是投了无数多的简历并且连个面试的机会都没有的帖子，这只会让我更焦躁。看了招聘条件后总觉得自己还是差点东西才能胜任这份实习，尽管对实习生其实并不需要多高的技能水平。鉴于这样的情况，我暂时还是打消了找实习的念头，打算花更多的时间再提升一下技能水平。\n\n\n最近因为学习算法中遇到了一些问题，又开始有些焦躁。在过去两年中每次在接触并且学习新东西的时候会产生各种的迷茫，也许对我来说没办法，自学总是不弯弯绕绕很难走到正确的路。很遗憾大一的时候自己的认知和视野没有照到相对正确的路上，导致了一些时间花在学习变化很快的主流技术上面，没有从计算机基础开始。\n其实我喜欢计算机相关，也愿意从事这份工作，但并不想做一个简单的CRUD开发者，想在一个喜欢的领域里贡献自己那份仅有的价值。也许期望太高了？这只不过是个最终理想罢了。我总是为项目里需要用到的技能而去学某些东西，但是学完之后从未觉得它们被我拥有过，只是单纯的拿它们用来服务所需的项目里，从来没想过自己能用它们做一些自己觉得有意思的事情，这是我意识到自己所缺的那部分。\n一直觉得焦虑是可以有的，但是不能长期焦虑影响到自己的生活。与其不停的让自己处于焦虑中，倒不如提升自己，多做事情，让自己在未来的日子里能施展能力的概率更大一点。\n在经济下行的环境中，个人的努力显得微不足道，我也做好了“尽管学再多的技术也找不到工作”的心里准备。也庆幸自己在不好的环境中还可以通过互联网认识到了诸多的优秀开发者，同样也可以看到世界级名校的公开课，从优秀的开发者中学到了很多并且得到了受益的建议与鼓励。他们如此谦逊并且愿意分享自己的经验给陌生人，也许这个群体受益于开源的思想吧。\n在大学两年最能影响到我的是Ray-Eldath，在3月底最焦虑和迷茫的日子里我写信给他寻求职业发展的建议，这也是我第一次以长文的形式写信给别人，虽然文笔并不是很好，但是我尽量的表达清楚。而在他的回信中我感到他的文字充满力量并不禁感叹文笔如此的好，翻过他的博客我知道这一定离不开他本人拥有浓厚的文学知识。\n在回信中让重新对以后充满期望的一句话就是：“‘人灵魂的欲望是其命运的先知’，每当在埋头苦读中感到疲乏、有退缩之意时，我总在心中默念这个句子，因为坚定而不屈的灵魂值得美好又光明的未来，他们在人群中熠熠生辉。我们要为成为那样的人而努力。”\n之前还想过并且不止想过一次，在城市里工作感到真的真的疲惫的那时，那就选择一个喜欢的城市去经营一个自己喜欢的店铺(也许是苏州？)，我向往最好一点的生活也就是这样了。甚至还有个想法就是做海洋救助的公益，很难实现，但是我心里是想做，也许这也是一个终极理想吧？但这都是留给自己的“退路”。\n大学这两年我也慢慢成为了知识的虔诚信徒，也明白知识是可贵的，虽然身处环境一般但敬畏知识。还算年轻，我还有很多喜欢的东西来支撑着我期许未来，很多很多喜欢的衣服还没有穿，被称之为“不夜城”的香港和“自由乌托邦”的阿姆斯特丹还没有去，有很多热爱和喜欢的事物还没有去接触。\n想起Ray-Eldath在信中提到过一篇题为《拥抱苦差事》的文章中里引用的一句话：“如果某个魔术所需的时间、金钱或练习的次数，比你（或任何一个普通人）所愿意付出的更多，那你就会被骗到”。如果你愿意拥抱苦差事，你就可以完成不可能完成的任务，但愿我们在拥抱苦差事之后也可以被更多一点的幸运所眷顾，让我们去展示这些“魔法”。\n写下这些也是想让自己在这段文字之后让自己重新期待未来，好好享受“暂时不用考虑社会里烦恼”的日子，安静的做自己喜欢的事情。\n","categories":["Daily"],"tags":["生活","思绪"]},{"title":"美学原理","url":"/2024/04/aesthetics.html","content":"\nUP主：西竹书院杨宁老师\n2021年课程链接：美学原理课程全集 共28讲 2021年春\n2020年课程链接：美学原理课程全集 共30讲 2020年春\n\n美学是什么与为什么美学为何：美学的学科特点\n对审美现象的反思（不等于评判）\n对审美规律的探寻（规律背后的规律，非规律本身，探寻是否应当有规律）\n对审美文化进行分析（历史背景，历史动因，意识形态）\n\n\n审美应当无功利性\n具象的事物让人联想到实用功能，抽象的事物反而具备无功利性，故而往往抽象的事物更美\n身体美学：身体与意识的关系美学\n\n美学何为：美学的学科性质\n美学的学科定位：人文学科（以生命&#x2F;人的存在为研究对象），但不是人文科学\n美学与自然科学：审美具有历史性、社会性、不完全与生理特性吻合\n美学与社会科学：美学从个体出发，社会科学从整体出发\n美学与人文科学：美学是学科，但不是科学\n\n\n\n\n美学的研究过程有强烈的主观介入（不回避个体的主观态度）——&gt;体现价值判断\n美学的研究对象不具有实体性（看不见摸不着）\n美学的研究结果基于主观判断，其结果无法验证\n\n\n美学研究的对象\n美及美的规律：柏拉图提出\n美本身是什么？——&gt;严格意义上的美学问题，但这个问题实际上是将美当做一样东西\n什么是美？——&gt;实际是问的美的具象\n\n\n艺术：美学是艺术哲学，典型人物黑格尔（美是具备精神性的，非自然性的）\n美感经验：审美研究包括审美经验、审美心理——&gt;纯粹客观的美不存在\n人与现实的审美关系（我国主流关系）：人把握世界的三种方式为认识论、伦理学、美学\n\n\n\n审美关系的四个维度\n人与自身：心里美学（格式塔美学、心理美学、视听美学等）\n人与文化：艺术哲学\n人与自然：环境美学\n人与社会：社会美学、文化工业、政治美学（代表雅克·朗西埃《美学的政治：可感性的再分配》）\n\n美学本体论：感性世界的美学祛魅\n前提问题：\n\n历史与逻辑统一问题：历史的审美发展问题符合美学的发展逻辑。故而更多的讲美学史，而且是西方美学史\n本体论问题：本体论即追问事物本质（是什么？区别于其他事物的本质特性）\n本质主义与反本质主义：西方20世纪之前倾向本质主义，20世纪之后倾向于反本质主义\n主观派和客观派的区别：审美判断倾向于主观，但也不是完全离开客观而存在，审美判断寻求普遍性\n\n\n美的规律与美的本质（从古希腊开始追问）\n毕达哥拉斯——&gt;强调美的规律性\n\n世界的本质是数（规律）\n美丑的区别：数是否和谐\n美的本质就是数的和谐—&gt;黄金分割\n\n\n苏格拉底——&gt;强调美的合目的性（美即有用、合适）\n\n美不是属性，而且不是固定不变的属性，是关系（有用、合适、符合目的）\n美的事物是相对的，变化的，但是美本身确实不变的\n\n\n柏拉图——&gt;本质决定存在\n\n线喻：即实物等于数理，实物现象后有一一对应的本质\n洞喻：认识真相是极为苦难的。制造了分野：现象世界（对本质世界的反映）、本质世界（真实世界）\n床喻：\n神造的床——&gt;理念——&gt;理念世界\n木匠造床——&gt;实物——&gt;是对理念世界的模仿\n画家的床——&gt;现实的摹本——&gt;摹本的摹本，与理念世界隔了三层\n\n\n迷狂：迷狂的状态下把握美（理念），回忆说——&gt;迷狂状态下神灵附体\n对于美本身的探讨：柏拉图《文艺对话录》中的《大希庇阿斯篇》区分美的事物与美本身，第一个去追问何为美本身\n影响：\n\n确立美的本质问题：美本身是什么？（当前以康德的观点为主流观点）\n美是抽象的、普遍的、客观的、不以人的意志为转移\n确立了美学研究方式——&gt;哲学\n\n\n\n\n\n\n美学·神圣秩序的证明\n奥古斯丁（古罗马，美是客观的——&gt;神学）\n\n代表作：《忏悔录》、《论三位一体》、《论美与适宜》\n观点：美的本质源于上帝——&gt;受普罗提诺的影响\n美的阶梯理论：物质美——&gt;精神美（道德、艺术）——&gt;上帝（本源的美）\n美的普遍特征：特征、数——&gt;要求整一、和谐、对称\n\n\n托马斯·阿奎那（意大利人——&gt;中世界神学）\n\n代表作：《神学大全》\n观点：\n美是通过感官使人愉快，美只有形式，不涉及内容，无关欲念（无利害）\n美的三要素：整一完善、比例和谐、色彩鲜明\n\n\n美与善的区别：善是满足人的愿望与需要，而美能引起人的愉快\n\n\n\n美学本体论：主观论的兴起与感性学诞生感官与经验\n夏夫兹博里（思想家、美学家、艺术家等）\n\n审美的内在感官说\n外在感官：触觉、听觉、视觉等，具有直接性，非理性\n内在感官：辨别善恶丑美——&gt;影响了康德\n\n\n美善同一：美是一种和谐、愉快，是一种善，美善都是自然神创造的\n\n\n哈奇生（夏夫兹博里的学生）\n\n内在感官（复杂、高级、理性）&gt; 外在感官（简单）\n代表作：《论美和德行的两种观念根源》\n绝对美（本源美，美的一种固有属性），相对美（比较的结果，比如艺术绘画）\n\n\n休谟（18世纪英国哲学家、思想家，纯主观唯心主义者）——&gt; 不可知论、怀疑论\n\n美的本质：美不存在客观标准，美的本质是在鉴赏者的心理。先有美感才有美\n同情说：同情与美有关系，不等同于怜悯，美是同情的想象——&gt;影响后来的移情说，内模仿说\n\n\n\n感性学的征兆与感性学的诞生\n卢梭（浪漫主义的开端） 政治——&gt;天赋人权；环保——&gt;返回自然 代表作：《科学与艺术》、《论人类不平等的起源和基础》、《社会契约论》\n伤感主义、自然主义：浪漫主义之父，强调自我情感的自由表达——&gt;崇尚自然美。真正的美源于上帝，人工造就的不美\n提出审美力的概念；审美力是指对事物美丑的判断力——&gt;先天的、天赋的\n\n\n\n","categories":["Note"],"tags":["美学"]},{"title":"《计算机组成与设计：软硬件接口》笔记","url":"/2024/02/share-computer-foundation.html","content":"记录一下关于学习计算机组成与设计的记录…\n参考书籍：《计算机组成与设计硬件&#x2F;软件接口》\n计算机硬件的操作数与高级语言程序不同，MIPS算术运算指令的操作数是很严格的，它们必须来自寄存器。寄存器由硬件直接构建且数量有限，是计算机硬件设计的基本元素。\n可以把寄存器想象成构造计算机”建筑“的”砖块“， 在MIPS体系结构中寄存器大小为32位，32位为一组的情况经常出现，因此在MIPS体系结构中将其称为字 (word)。\n\n字:计算机中的基本访问单位，通常是 32 位为一组\n\n高级语言的变量与寄存器的一个主要区别在千寄存器的数量有限，寄存器个数限制为32个的理由可以表示为硬件设计三条基本原则中的第二条 : 设计原则2: 越小越快，而大量的寄存器可能会使时钟周期变长，因为电信号传输更远的距离必然花费更长的时间 。\n尽管可以简单使用序号0 - 31表示相应的寄存器，但MIPS约定书写指令时用 一个 $符后面跟两个字符来代表一个寄存器。\n现在，我们使用$s0,$s1来表示与 C 和 Java程序中的变量所对应的寄存器，用$t0, $t1 …来表示将程序编译为MlPS指令时所需的临时寄存器。\n例如:\nf &#x3D; (g + h) - (i + j) \n变量f、g、h、i和 j 依次分配给寄存器$s0、$s1、$s2、$s3 和 $s4。编译后的MIPS代码是什么？\n除了将变量用上述寄存器代替，将两个临时变量用$t0 和 $t1 代替\nadd $t0, $s1, $s2 # g + h\nadd $t1, $s3, $s4 # i + j\nsub $t0, $t0, $t1 # (g + h) - (i + j) \n\n存储器操作数处理器只能将少量数据保存在寄存器中，但存储器有数十亿的数据元素。因此，数据结构（如数组和结构）是存放在存储器中的\n如上所述，MIPS 的算术运算指令只对寄存器进行操作，因此，MIPS 必须包含在存储器和寄存器之间传送数据的指令。这些指令叫作数据传送指令（data transfer instruction）。为了访问存储器中的一个字，指令必须给出存储器地址（ad-dress）。存储器就是一个很大的下标从0开始的一维数组，地址就相当于数组的下标。例如，在图2-2中，第三个数据元素的地址为2，存放的数据为10\n\n数据传送指令：在存储器和寄存器之间移动数据的命令。地址：用于在存储器空间中指明某特定数据元素位置的值\n\n将数据从存储器复制到寄存器的数据传送指令通常叫取数（load）指令。取数指令的格式是操作码后接着目标寄存器，再后面是用来访问存储器的常数和寄存器。常数和第二个寄存器中的值相加即得存储器地址。实际的MIPS 取数指令助记符为Iw，为load word的缩写\n与取数指令相对应的指令通常叫作存数（store）指令；它将数据从寄存器复制到存储器。存数指令的格式和取数指令相似：首先是操作码，接着是包含待存储数据的寄存器，然后是数组元素的偏量，最后是基址寄存器。同样，MIPS地址由常数和基址寄存器内容共同决定。实际的MIPS 存数指令为 sw，即 store word 的缩写\n因为MIPS是按字节编址的，所以字的起始地址必 须是4的倍数。这叫对齐限制 (alignment restriction) , 许多体系结构都有这样的限制\n例如：\n假设变量h存放在寄存器$s2中，数组A的基址放在$s3中。试编译下面的C赋值语句：\nA[12] &#x3D; h + A[8]\nlw $t0, 32($s3) # A[8]\nadd $t0, $s2, $t0 # h + A[8]\nsw $t0, 48($s3) # Stores h + A[8] back into A[12]\n\n为了得到正确的字节地址，与基址寄 存器$s3相加的偏移量必须是 4 x 8, 即 32, 这样才能正确读到 A [8]\n数据传送指令中的常量(本例中为8和12) 称为偏移量 (offset) , 存放基址的寄存器(本例中为$s3) 称为基址寄存器 (base register)\n\n许多程序的变量个数要远多于计算机的寄存器个数。因此，编译器会尽量将最常用的变量保持在寄存器中，而将其他的变量放在存储器中，方法是使用取数&#x2F;存数指令在寄存器和存储器之间传送变量。将不常使用的变量（或稍后才使用的变量）存回到存储器中的过程叫作寄存器溢出\n\n寄存器与存储器相比，访问时间短、吞吐率高，寄存器中的数据访问速度快并易于利用，访问寄存器相对于访问存储器功耗更小。因此，为了获得高性能和节约功耗，指令集的体系结构必须拥有足够的寄存器，并且编译器必须高效率地利用这些寄存器。\n","categories":["Note"],"tags":["计算机组成与设计","计算机基础"]},{"title":"一个仅供参考的规划","url":"/2023/09/SelfExperience.html","content":"为什么写写这篇规划的初衷是因为在我大一刚开始接触程序开发时，我也有很多困惑，对很多东西没有清楚的认识，也没有人指点，很容易迷茫。从那时一路走过来，也在各种论坛受到了类似文章和优秀的人的影响，我也想做一件可以帮助别人的事。\n\n\n其实一直在考虑要不要写这篇文章很久，主要原因是因为我个人的知识学习仍在持续，同时我也在考虑自己是否有足够的能力提供有价值的建议，以及是否能够确保我的陈述既严谨又清晰。因此，还是需要花一些时间来构思和陈述这篇文章。\n实际上，我在这篇文章中列举的几门技术在计算机科学（Computer Science） 领域来说，微不足道。计算机领域方向庞杂，知识浩如烟海，每个细分领域如果深究下去都可以说学无止境。因此，一个清晰明确的学习规划是非常重要的，如果你顺利了进入软件开发专业，那么目前你在整个计算机的领域中，就已经确定了大方向类就是软件工程。\n自学这条路走过不少弯路，最终提炼出了下面的内容。我希望通过这篇文章，分享我在过去两年学习程序开发的心得和经验，为海院信息工程学院的新同学，尤其是那些与软件开发相关的同学提供一些帮助，哪怕只是微小的帮助，我也会感到非常开心。\n必须要提醒的：\n大一统一开设的专业课程有Java基础入门、Web设计、Linux、MySQL。在大二就要开始分前端方向和后端方向，两个方向的教学内容也是极其不同的，但不论是前端后端，在整个大学生涯中都需要把计算机基础学完。由于我选了后端方向，所以本文的部分课程推荐更适合偏向后端方向的同学。\n阅读体验说明：\n\n电脑端的同学可根据网页左上角来预览文章的目录，手机端的同学可点击右上角搜索图标左边的目录按钮进行查看，点击即可跳转到对应标题的内容。\n文中具有蓝色的字样是网页链接，点击即可跳转到对应站点。\n\n本篇属个人心得和经验，具有较强主观性陈述，仅供大致参考，如有疑问和错误，欢迎通过评论或邮件沟通。\n心路历程讲点自己在学校两年间的心路历程\n大一：2021.10至2022.06在高考完之后，专业的录取结果是软件开发专业的，当时一位老师也开了线上班会，带所有软件开发的学生浏览了一遍我校教学计划，编程语言(Programming Language) 用的就是用Java语言，于是就抱起了提前一点学Java的想法了。在Bilibili一搜Java课程一大把，满眼看过去大部分都是机构课程，其实当时觉得机构课程都非常非常棒，尤其像黑马程序员，尚硅谷至今也是目前公开课程最多，质量优秀的两大机构。不过这个结论是我后来才产生的，在起初充斥着各大机构Java课程的搜索结果里，我根本就无法判断结果里内容的质量高低。于是我就开始在百度搜寻各种建议，听哪一家的比较好？大家都推荐黑马程序员，但集数真的很多很多，他们把知识点的讲解细分成很多集，不过好在每集其实并不是很长，于是我就开始看课并且跟着写代码。\n其实当时Java被很多机构宣传的很多，也进一步劝了很多人进入了Java的坑。重要的是2021年计算机的行情还算可观，我当时的想法就是学好Java这门语言和流行的开发框架就一定可以找个好工作了。\n后面看到不及集数的1&#x2F;3，我就开始听的有点懵的状态了，后面索性又在众多搜索结果了换了一套教程。学到数组差不多就开学了，后面就在学校课堂上课，不过那会自己的进度已经赶在了老师教学进度之前，于是就继续Java基础语法的进度了。\n随后，在大一第一学期，当时的任课Java的蒋玉婷老师在课堂上讲了一下蓝桥杯的比赛，后面因为比赛需要训练时间和个人规划的冲突犹豫了一段时间，最终我还是联系了老师成为预选，在2022年的3月春季开学老师确定好了人选，最终也成功的报名了比赛，最最最重要的是学校为每位参赛选手提供了报名费以及蓝桥杯VIP题库的名额。在4月份比赛之前都是在蓝桥杯官网做练习题，其实当时我已经意识到参加算法比赛是要有一定的编程语法基础，数据结构基础，以及基础算法基础的，不过当时没有这些课程的教学，我只有简单的Java语法基础，并且时间有限，我只能报以理解题意的思维去刷题或看题解。\n最终水了一个省二等奖的名次，同参加的校友还有一位获得了省一等奖和一位进入了国赛的选手。不过是一次体验，也算是一份小小的荣誉，很大程度上的增加了我对技术学习的信心和热情，也感谢蒋老师。大一除了Java基础语法，同时也学了基础的Web网页设计，包括HTML，JavaScript，CSS，其实我更喜欢前端，因为我可以通过编码设计出自己喜欢的样式，并且也享受其中，Web网页设计的许欢老师也是一位讲课非常棒的老师，受益于她任教的这门课，大一第二学期结课之前完成了最后一个大作业（如图）。\n主页部分：\n\n博客部分：\n\n在整个大一有部分是课堂听讲，一部分情况下自学的较多，大一除了Web，Java基础以及MySQL，还有其它比较实用的操作课程，比如Linux。\n其实大一第二学期中旬才把Java语法学完，这个进度是有点慢的，是因为当时按照那个课程一直看到进阶的知识，后来才意识到的。其实那部分知识很难，当时也不怎么用的到，进阶的几个技术点都可以单独拎出来学习的，甚至到现在也有点遗忘了。\n大二：2022.08至2023.07在大一时候看过很多建议，大多数人强调了计算机基础的重要性。大一结束完的暑假，我就着手去学习了南京大学-袁春风《计算机系统基础》，这门课讲的更多的是计算机组成，其实看的也是有点囫囵吞枣，但是对计算机运作的原理算是有了一个简单的认识。在暑假期间开始折腾了一个博客，就是现在的博客，虽然花了大量的时间去查阅搭建和使用，但是最终能学到的不止于这些，在今年9月开学我又重新装饰了一下博客，就如你现在看到的样子。\n大二实行专业分流，软件技术分成前端(front-end)和后端(back-end)，我选择了后端(其实那时候我对后端的概念比较模糊)\n第一学期开始后端框架的教学，其实我在课堂上没有听懂，后面是课下花了时间又去自己学，课堂上听不懂的结果无疑是会占用大量的课下时间，导致课上时间是没有价值的。其余时间学习了中科大-郑烇《计算机网路：自顶向下》。计算机基础是枯燥的，没有编码练习又很难真正的理解知识点，导致了我在大二第二学期二刷这门课程，不过这一遍对计算机网络知识的框架又进一步深入和理解，但是对于这次的不足还是缺少实验的实践对知识进一步理解。网上有实践项目但是前置知识缺少无法继续进行，所以就计划搁置在后面补充完前置知识再继续完成实践项目。\n第二学期依旧是框架技术的学习，学习的规划分布也如同第一学期，第二学期也是心情和技术提升波动最大的一学期。第一是：随着互联网寒冬的来临，众多企业开始裁员，我质疑自己是否能坚持这条路，面对未来还没就业就已经先失业的环境我很焦虑。第二是：我是一个倾向于喜欢计划再行事的人，不规划好一些东西，我总是在任何时候会去想着这些事情的顺序，担心忘记。所以第二学期也因为自己没预先充分了解课程前置知识，规划了几门课程的学习目标，导致学的过程很痛苦，过度认为是因为自己足够笨拙。然后和朋友沟通，谈心，了解原因后，于是重新规划自己的路线，最终这些不好的情绪也随之散去，感谢我的朋友们。在第二学期的5月中旬把数据结构学完，后面就在LeetCode刷题了。持续了一个半个月左右，然后临近放假也没再刷了。刷题也很痛苦的，刷到mid的时候，看题解也理解不了代码逻辑的话会极度痛苦。\n其实本来计划着在大二第一学期结束前找份实习工作，在工业界中学习比自己去蒙着头学习的效率要高很多，在工业界实习你能真正的了解实际开发过程与环境，快速学习到主流的技术。但是行情不是特别的好，暑假实习的人又很多，再加上学历的原因，所以就暂时放弃了找实习的想法，继续在家学了。\n大二结束的假期，也就是这个暑假，又重新学习了计算机组成、操作系统(未完) ，跟的课程是之前比较畏惧的CMU 15-213 CSAPP 深入理解计算机系统，但是没有做Lab以及只听了几张重要的章节，但计划在后面抽时间尝试做。不过在大二的寒假只读了这门课程配套的书籍 《Computer Systems: A Programmer’s Perspective》 简称：CSAPP，中文名：《深入理解计算机系统》 但是配套的Lab做完Lab1就已经到达能力的极限，但还差一点点才完成整个Lab1。\n大二一直都在偏向于计算机基础的学习，不过在Spring Boot学完之后自己跟了一个简单的增删改查(CRUD)的项目，虽然项目不是很难，但是跟着做完之后会对Spring Boot开发有一个进一步的理解和实战技能的提升，不过这些还远远不够，增加开发经验需要阅读更多的开源项目和使用Spring Boot做项目，我会在后面的课程推荐里把这门项目课程放出来。\n自学很难避免走写弯路和时间的浪费，虽然有时候会轻微偏离正确的方向，但总体来说两年的时间颇有收获，比如技术的掌握，视野增加，信息的搜索和辨别能力。其实除了文章中提到的的技术和知识，还有一部分学习和折腾过程中也学到了很多，单独去学一门技术其实能学到的仅仅是你目标的东西，很多技术大多是都在搜寻问题和解决问题的过程中学习到。\n路线先阅读这里：\n\n课程推荐里的大部分是我看过的，每个技术点只需从中选择一门合适的观看就够了，还可以选择除本文推荐外的课程，比如黑马和尚硅谷的课程，他们的所有技术都有公开课程。\n\n路线方面有两个大致的路线可以参考，选择路线一的直接完全可以按照黑马和尚硅谷的路线来就行，如果你觉得黑马和尚硅谷路线里自带的课程不适合你，那么你可以在我我的课程推荐目录里选择一门就好。选择路线二的你就按照我给你的建议去看。不过由于有的视频在Bilibili可能会因为未知原因被下架，所以目录里的链接可能会有失效的情况，如有失效，请及时评论进行反馈。\n\n\nPS:关于路线和课程推荐，不做任何绝对的强制推荐，可供大致参考。如果你在某个时间过后意识到之前阅读的这篇文章对你有益或者适合，那么你可以尝试。\n路线一：仅仅学习主流技术+项目实践如果你只是想掌握并且又希望学的内容比学校多，可以按照 黑马程序员或者尚硅谷的技术路线学习，在之前提到过，这两大机构的课程质量是优秀的，我也听过这两个机构的部分课程，路线里也有给推荐项目实战教程。\n但要说的一点是，路线的技术点是顺序是这样的，但是课程并不用一定听他们的，如果你听不明白学习路线中某一门课，你完全可以换一套教程，比如Java基础你觉得学习路线里自带的课程并不适用于你，你可以寻找一门更适合自己的Java基础课程。但找到一门合适的课你需要不断的听，后面可能又听不懂，然后再换…就这样反复循环，这无疑是浪费时间的。而且大部分机构的课程是非常冗余和多集数的，我在后面的具体技术课程推荐目录里会分享相对不错的课程，但不保证一定适合你，有时候开始听不懂的时候，不能忽略的一点是考虑一下是不是自己的问题。不过缺少了计算机基础的支撑，你在面对很多问题可能很棘手，并且你的技术成长可能很快遇到瓶颈，不建议只走这条流行技术路线。\n路线二：计算机基础+主流技术+项目实战其实这一路线也就是在上面两大机构路线中并行学习计算机基础知识，这个路线是贯穿整个两个年的时间，在整个大一学校会开设Java基础，Web设计，Mysql，Linux；大二差不多就是Java Web，Spring， Spring Boot以及顺便会讲Maven。在两年的时间里，你可以合理的安排这些技术的学习，包括兼顾学校的开设的课程，其实如果你在课堂上学好，就不用课下再去系统性学习了，忘记的话快速复习一遍就行(我也有忘记并且二刷课程的时候)。\n因为学校的教学顺序也大概和一些培训机构的顺序是一样的，所以大可按照每学期学校开设的课程提前学习这些课程，剩下空闲的时间可以用来学习计算机基础。\n我的建议是：\n\nC语言的基础学完，可以听浙江大学-C语言入门与进阶 翁恺，后面就可以学习《数据结构与算法》，Java可以在其他空闲时间并行学习，这样既能保证跟进学校课程进度，也能同时掌握C语言和数据结构的知识，一切的时间安排和效率都取决于你自己，我强调的是学习《数据结构与算法基础》这门课的前置知识你需要学习C语言的基础语法。\n\n整个大一结束，你会学完大一开设的课程，大一暑假你可以开始《计算机组成原理》的课程\n\n如果你是后端，大二一整年你会学习各种基于框架的开发技术。你尽量在大二第一学期完成《操作系统》的学习，大二寒假或者大二第二学期的空闲时间完成《计算机网络》的学习。如果时间安排受限，那么你可以选择在大二结束的暑假完成《计算机网路》，在大三开学前，一定要完成计算机基础四门课的学习。\n\n\n计算机基础部分的整体顺序：数据结构与算法基础 → 计算机组成原理 → 操作系统 → 计算机网络\n课程推荐\n推荐分为计算机基础部分和主流技术部分\n\n计算机基础部分听计算机基础之前可以尝试听下这门课2023哈佛大学CS50，这门课UP主到2023年9月5日为止还在持续翻译中，后续应该会翻译完。这门课需适合初学者，但是可能需要有一定的编程经验。\n“CS50” 是哈佛大学的一门计算机科学入门课程，这门课程旨在帮助学生建立计算机科学和编程的基础知识。\n内容包括：C语言编程、数据结构、算法设计与分析、计算机科学的基本概念、数据库、Web编程、安全性、软件工程。\n计算机组成原理\n南京大学-袁春风《计算机系统基础》\n 此课分为五个大部分，听完三这一部分即可，具体点击这里查看课程列表。\n\n\n操作系统\n哈工大-李治军《操作系统》\n\n数据结构\n青岛大学-王卓《数据结构与算法基础》\n 讲的非常非常细心，通俗易懂，老师很友善。学数据结构与算法的前提是C语言基础入门，因为你需要看懂老师PPT上的代码示例。\n\n\n计算机网络\n中科大-郑烇《计算机网路：自顶向下》\n 也是一位非常出色的老师。因为是课堂录播嘛，我记得印象最深的是有一节课可能没有录播，同时也是最重要的一节课，但是！老师亲自对着空教室又录了一遍这节课，然后课中也不停的强调本节课重要的知识点。\n\n\n主流技术部分Java基础语法\n语法基础一定要学牢固。\n\n\n马士兵教育-2021版java就业班全套视频讲解 \n 这门课是我自己当初看的，他也包括了框架开发技术，还有工具的技术，所以只需要关注P1-P171是基础入门，P172-P351是进阶，这个进阶部分也是前面提到的导致我学语法进度比较慢的原因，进阶部分可根据自己能力和时间多少来选择听取，不过最终也是要补这部分知识的，这部分进阶技术不受限于编程语言，也就是说任何想成为一名合格的Coder都需要学习并掌握这部分技术，只是实现这些技术的编程语言可以是任何。\n\n楠哥2021最新Java零基础实战全套教程，从入门到精通\n 这位讲师我在大一结束的暑假里学JavaWeb发现的，我大致看了一下这门课程只有60h+的时长，我听过这位讲师的其他两门课程都觉得非常清晰容易理解。\n\n\n数据库\nMySQL数据库入门到精通\n\nJavaWeb\n这个一定跟着课程操作一遍，不管哪个课程要跟一遍！这门课程就是很早之前用通过各种技术以及Java构建Web应用的操作，搞懂Servlet，JDBC，还有整个JavaWeb程序的大概运行逻辑和顺序。\n\n\nJava Web从入门到实战\n Java web 是指由Java语言开发出来可以在万维网上访问浏览的程序。\n Web通过一系列的通信实现与Java的交互，Java是你的后台，进行逻辑处理，中间层进行数据的交互，Web显示给用户来看。就好像你买东西付款，钱是你能看到的–钱：Web，收钱和找零通过手来执行–手：中间层的作用，大脑来算出应该找零多少–大脑：Java后台。\n 这门是在大一结束暑假提前预习JavaWeb找到的，讲的比较清晰，是我目前见到的比较小众和干净的Java Web课程了。\n\n\nSpring Mvc以及Spring\n先学Sring MVC，再学Sping。关于Spring和Java EE的区别，可参考这篇文章，如有不懂，可自行搜索查阅更多相关资料。\n\n\n2022年厦门大学JavaEE平台技术课程\n 这门是在去年10月多份Bilibili首页刷到的课程，当时试听了一下感觉讲的非常清晰透彻，包括Java EE、Spring以及Spring Boot技术的历史发展。不过我听了前几节课发现比较偏向于技术的概念的讲解，没有太多上手的实际操作。可以通过这门课快速了解基于Spring框架开发的流行技术，实操之前看可以当做了解，实操之后可以再次用作于知识的巩固，毕竟课时不长。\n\n动力节点SpringMVC框架实战教程\n 在计算机科学中，MVC是一种软件设计模式，这种模式将应用代码组织成三个相互交织的部分——模型、视图和控制器。\n 模型是与数据库交互的逻辑；视图是用户接口和交互，控制器是是视图和数据库之间的中介。\n 大多数情况下，视图不直接和模型交互——这个功能由控制器执行。\n\n跟老杜从零学spring入门到高级\n\n\nSpring Boot\nSpring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。更多内容请参考这里\n\n\n黑马程序员SpringBoot2全套视频教程\n\n黑马程序员SSM框架教程\n SSM是：Spring&#x2F;Spring Boot + SpringMVC + Mybatis&#x2F;Mybatis Plus 三项技术，每一个技术的英文首字母组合简称SSM。\n 推荐直接看这门，因为时长短，以上那些课程的内容都是针对每一项技术的细致讲解。这套SSM教程是直接对三大技术整合的教程，也包括各个技术知识点的讲解，只不过没有单独技术讲解的细致。\n\n\n中间件及工具\n4小时Redis极简入门\n\n黑马程序员Maven全套教程\n\n一小时Git教程\n\n黑马程序员最新MybatisPlus全套视频教程\n\nMyBatis零基础入门教程\n MyBatisPlus是MyBatis的加强版本，初学时掌握MyBatis即可，但后续有时间可以再学一下MyBatisPlus，技多不压身，根据需求选择用MyBatis还是Plus。\n\n\n项目实战\n黑马程序员Java项目实战《瑞吉外卖》\n 这门大多数人都在推荐，而且很多做过这个项目的人已经把它改个项目名写在了简历上。\n\n2023全网最简单但实用的SpringBoot+Vue前后端分离项目实战（第一季）\n 非常非常推荐这门实战课，简单易懂，但是前置知识是要学完之前的框架以及部分工具的技术。这门课程目前有两季，第二季你们自行去UP主的主页里寻找。在大二的第二学期中旬左右，我跟了这个项目，跟完之后我对Spring Boot的开发又有了更深的理解，包括整个后端开发流程以及前后端对接的过程。\n\n若依\n建议先做完2项目之后再来看这个，这个项目是一个优秀的开源项目，大家选择前后端分离的版本即可。官方文档其实我也很难看懂，不过大家可以看一个博主讲的视频：若依前后端分离版，通俗易懂，快速上手，这个视频讲的仅仅只是一部分，更深的技术探寻还需要在你掌握更多知识或者有能力的时候再去研究项目源码。\n\n\n写在最后\n关于信息检索\n  搜索引擎百度和Bing可以相互补用！从数据库来说，百度比Bing收录的中文内容要多，如果你碰到的时中文相关的问题而且确实找不到相关内容，那么就用百度，搜索引擎是工具，能用好用才是王道。知乎专栏、简书、博客园、 CSDN 中有大量中文笔记，这些都是别人嚼烂了的东西，基本是别人踩坑的经验。\n\n关于英语\n  英语一定好好学，然而我也在更好的去掌握它。更值得强调的是英语是一门语言也是工具，请不要把它当做一门学科来学。计算机科学发展这么多年，它的起点就是英语，任何前沿的知识以及新技术的发布都是以英文作为官方语言的，包括很多技术和工具的官方文档都是英文，虽然部分有中文的版本，但是有时候并不一定是原汁原味。当你遇到一门非常优秀的大学公开课时，只有英语字幕，没有中文字幕的时候，你会感到非常非常的无助，因为语言障碍而没有能力去欣赏这门课程，在我看来更多的是遗憾吧，所以会更加的意识到掌握英语的必要性。\n\n关于俱乐部和比赛\n  除非你非常感兴趣的运动俱乐部，以及兴趣俱乐部是有价值的，其余多半是对专业没有太多用处的，而且会耽误大量的时间，我整个学生期间没有参加任何一个部门，不过这也意味着你要几乎抛弃了社交。也许你进去只会有干不完的活和开不完的会？\n  专业相关比赛可以参加，例如前面提到的蓝桥杯、开发技能大赛等等，具体的可以询问相关任课老师。\n  非常重要的一点：参加这些前提是要衡量一下俱乐部和你专业学习的时间.\n\n书籍推荐\n\n《操作系统导论 》\n  英文名：《Operating Systems: Three Easy Pieces》\n  这本书深入浅出，很多概念讲的非常通俗易懂，并且有很好的例子去帮助你理解一些抽象的概念\n\n《计算机网络：自顶向下方法》\n  英文名：《Computer Networking: A Top-Down Approach》\n  从应用层协议开始沿协议栈向下逐层讲解，从实现、应用的角度明白各层的意义，进而理解计算机网络的工作原理和机制\n\n《深入理解计算机系统》\n  英文名：《Computer Systems: A Programmer’s Perspective》\n  卡耐基梅隆大学CMU-15213的配套书籍，里面内容众多，更是一本计算机组成和操作系统的结合体，涉及的广泛但是并不是很深入。\n\n\n\n\n因为某些原因，其实部分计算机基础部分我并没有及时在正确的时间段安排学习，但好在大二结束时，基础课程都基本的完成了。只是现在发现这样安排是最妥当的，所以在上面给了我认为比较合理的顺序。\n更好的学习计算机基础以及那些主流技术，前提一定是有一定的兴趣，兴趣是学习任何的自驱力，如果没有对这门学科根本没有兴趣，那么学起来是非常痛苦的，请更可能的对你感兴趣的技术保持好奇心，并且探索。计算机世界里真的真的有很多好玩的东西，很酷的东西。之前在朋友推荐下读过一篇题为《拥抱苦差事》的文章中里引用的一句话：“如果某个魔术所需的时间、金钱或练习的次数，比你（或任何一个普通人）所愿意付出的更多，那你就会被骗到”。如果你愿意拥抱苦差事，你就可以完成不可能完成的任务，但愿我们在拥抱苦差事之后也可以被更多一点的幸运所眷顾，让我们去展示这些“魔法”。\n技术不断的更新迭代，学习也会持续不断，我们会以终身学习者的身份继续学习。我在后面也计划暂时放下技术的学习去备考升本，本身寒冷的环境中没有学历很难再有展示机会的舞台。\n直到现在我也经常会感到焦虑、偶尔的迷茫，然而我深知这些情绪总是无法避免的，我清楚自己的这种状态不会持续很久，也会积极的通过一些精神食粮来缓解这种情绪。所以还是希望大家在专注一件事情的时候，也别忘了探索让自己为之振奋的事情，它或许会在未来的某一刻慰藉你的心灵。\n引用一句《死亡诗社》的台词 :\n\n“医学、法律、商业、工程，这些都是崇高的追求，是维持生命所必需的。但诗、美、浪漫、爱，这些才是我们活着的意义。”\n\n长路慢慢，希望大家保持身心健康，祝学习顺利，一起加油！\n由于访问不稳定因素，点击此处Notion备用页面\nPoluk\n2023年9月6日写于沁园\n","categories":["Note"],"tags":["总结"]}]